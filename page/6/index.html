<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="5AUIVYTbHIAuz-eQtxSfZbWW5eg9_EVZMSQycIuXrG0">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"theme-next.js.org","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.15.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/config.min.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="亦彤blog">
<meta property="og:url" content="https://theme-next.js.org/page/6/index.html">
<meta property="og:site_name" content="亦彤blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yangpengbing">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://theme-next.js.org/page/6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/6/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>亦彤blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-43861RVV8R"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-43861RVV8R","only_pageview":false}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/third-party/analytics/google-analytics.min.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="亦彤blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">亦彤blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-bell fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">58</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yangpengbing"
      src="/images/logo.svg">
  <p class="site-author-name" itemprop="name">yangpengbing</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhcHB5NTE4" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;happy518"><i class="fab fa-github fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>
<div class="cc-license animated" itemprop="sponsor">
  <span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="120" src="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://theme-next.js.org/jvm/2018-04-02-JVM%E7%B3%BB%E5%88%97%E4%B9%8BJVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.svg">
      <meta itemprop="name" content="yangpengbing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦彤blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 亦彤blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/jvm/2018-04-02-JVM%E7%B3%BB%E5%88%97%E4%B9%8BJVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">JVM系列之jvm内存结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-02 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-02T00:00:00+08:00">2018-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>所有的java开发人员可能会遇到这样的困惑？我该为堆内存设置多大空间呢？OutOfMemoryError的异常到底涉及到运行时数据的那块区域？该怎么解决呢？其实如果你经常解决服务器性能问题，那么这些问题就会变得非常常见，了解JVM内存也是为了服务器出现性能问题的时候可以快速的了解哪块内存区域出现问题，以便于快速的解决生产故障。</p>
<p>先看一张图，这张图很清晰的说明JVM内存结构布局。</p>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/jvm03.png" loading="lazy"></p>
<p>JVM内存结构主要有三大块：堆内存，方法区和栈，堆内存是JVM中最大的一块内存区域，有年轻代和老年代组成，而年轻代内存有被分成三部分: Eden空间，From Survivor空间和To Survivor空间，默认情况下年轻代按照8:1:1的比例来分配；</p>
<p>方法区存储类信息，常量，静态变量等数据，是线程共享的区域，为与java堆区分，方法区还有一个别名Non-Heap(非堆)；栈有分为java虚拟机栈和本地方法栈主要用于方法的执行。</p>
<h1 id="JVM内存的参数配置与调优"><a href="#JVM内存的参数配置与调优" class="headerlink" title="JVM内存的参数配置与调优"></a>JVM内存的参数配置与调优</h1><p>在通过一张图来了解如果通过参数来控制各区域的内存大小</p>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/jvm04.png" loading="lazy"></p>
<p>堆内存的接口和内存限制参数</p>
<p><img src="http://1.file.leanote.top/59dd8e27ab644110ea00037f/1507692006806_6.png?e=1542619030&token=ym9ZIrtxjozPN4G9he3-FHPOPxAe-OQmxzol5EOk:ynl6-k9K6esU6ow1iTUM2oXbw3Q" loading="lazy"></p>
<p>控制参数：</p>
<ul>
<li>-Xms设置堆的最小空间大小</li>
<li>-Xmx设置堆的最大空间大小</li>
<li>-XX:NewSize设置新生代最小空间大小</li>
<li>-XX:MaxNewSize设置新生代最大空间大小</li>
<li>-XX:PermSize设置永久代最小空间大小</li>
<li>-XX:MaxPermSize设置永久代最大空间大小</li>
<li>-Xss设置每个线程的栈空间大小</li>
</ul>
<p>JDK8之后JVM没有方法区概念，所以没有PermSize参数设置取而代之的是Metaspace，参数设置为</p>
<ul>
<li>-XX:MetaspaceSize, 初始空间大小，达到该值就会触发垃圾收集器进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就会适当降低该值。如果释放了很小的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。</li>
<li>-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。<blockquote>
<p>除了上面两个指定大小的选项以外，还有两个GC相关的属性：</p>
</blockquote>
</li>
<li>-XX:MinMetaspaceFreeRatio，在GC之后，最小的metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</li>
<li>-XX:MaxMetaspaceFreeRatio，在GC之后，最大的metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</li>
</ul>
<p>没有直接设置老年代的参数，但是可以通过设置堆空间大小和新生代空间大小两个参数来间接控制。</p>
<blockquote>
<p>老年代空间大小&#x3D;堆空间大小-新生代空间大小</p>
</blockquote>
<p>从更高的一个堆纬度再次来看JVM和系统调用之间的关系</p>
<p>内存是计算机中运行系统和软件的场所，将内存划分为不同的区域只是人为添加的概念，目的是为了更好的描述Java虚拟机对内存的管理。</p>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/jvm05.png" loading="lazy"><br><img src="https://wenshixin.gitee.io/blog/2018/08/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.png" loading="lazy"></p>
<p>方法区和堆内存是所有线程共享的内存区域，而java栈和本地方法栈，程序计数器是线程私有的内存区域。</p>
<p>下面我们详细介绍每个区域的作用；</p>
<h1 id="Java堆-Heap"><a href="#Java堆-Heap" class="headerlink" title="Java堆(Heap)"></a>Java堆(Heap)</h1><p>对于大多数应用来说，java堆(Java Heap)是java虚拟机管理内存中最大的一块，Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，此内存的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
<p>java堆是垃圾收集器管理的主要区域，因此很多时候也被称为&quot;GC堆&quot;. 如果从内存回收的角度看，由于现在收集器基本上都是采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；在细分一点的有Eden空间，From Survivor空间和To Survivor空间等。</p>
<p>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存当中，只要逻辑上是连续的即可，就像我们的磁盘空间一样，在实现时，既可以实现固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的(通过-Xms和-Xmx控制)。</p>
<p>如果在堆中没有内存完成实例分配，并且堆内存也无法再扩展时，将会抛出OutOfMemoryError异常。</p>
<h1 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区(Method Area)"></a>方法区(Method Area)</h1><p>方法区(Method Area)与堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述成为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap(非堆)，目前应该是与Java堆区分开来。</p>
<p>在方法区中，有一部分被称为运行时常量池，常量池除了用于存放在编译期生成的各种字面量和符号引用外，还存储了直接引用。运行时常量池具有动态性，常量并不一定是在编译期才会被放入常量池，在运行期间也有可能有新的常量进入池中，如调用String类的intern()方法就会将字符串对象放入字符串常量池中。</p>
<p>对于习惯于在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称之为&quot;永久代&quot;(Permanent Generation), 本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。</p>
<p>Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者扩展外，还可以选择不实现垃圾收集，相对而言，垃圾收集行为在这个区域是相对比较少出现的，但并非数据进入了方法区就如永久代的名字一样&quot;永久&quot;存在了，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收成绩比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。</p>
<p>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将会抛出OutOfMemoryError异常。</p>
<p>方法区有时候被称为持久代(PermGen)</p>
<p><img src="http://ifeve.com/wp-content/uploads/2015/05/JUtH_20121024_RuntimeDataAreas_2_MemoryModel-1.png" loading="lazy"></p>
<p>所有的对象在实例化后整个运行周期内，都会被存放在堆内存中，堆内存又被划分为不同的部分：伊甸区(Eden)，幸存者区域(Survivor Space)，老年代(Old Generation Space).</p>
<p>方法的执行都是伴随着线程的，原始类型的本地变量以及引用都存放在线程栈中，而引用关联的对象比如String，都存放在堆内存中，为了更好的理解上面这段话，我们可以看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> Logger.getLogger(HelloWorld.class.getName());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">formatter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;dd.MM.YYYY&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">today</span> <span class="operator">=</span> formatter.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        LOGGER.info(today + <span class="string">&quot;: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段程序的数据在内存中的存放如下：</p>
<p><img src="http://ifeve.com/wp-content/uploads/2015/05/JUtH_20121024_RuntimeDataAreas_4_MemoryModel.png" loading="lazy"></p>
<p>通过JConsole工具可以查看运行中的java程序的一些信息，堆内存分配，线程的数量以及加载的类的个数：</p>
<p><img src="http://ifeve.com/wp-content/uploads/2015/05/JUtH_20121024_RuntimeDataAreas_5_JConsole.png" loading="lazy"></p>
<h1 id="程序计数器-Program-Counter-Register"><a href="#程序计数器-Program-Counter-Register" class="headerlink" title="程序计数器(Program Counter Register)"></a>程序计数器(Program Counter Register)</h1><p>程序计数器(Program Counter Register)是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器，在虚拟机的概念模型中(仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现), 字节码解释器工作时就是通过改变这个计数器的值来获取下一条需要执行的字节码指令，多支，循环，调转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>由于java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器(对于多核处理器来说是一个内核)只会执行一条线程中的指令。因此，为了线程切换后恢复到正确的执行位置，每条线程都需要有一个独立的计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为线程私有的内存。</p>
<p>如果线程正在执行的是一个Java方法，这个计数器记录的值是正在执行的虚拟机字节码指定的地址。如果正在执行的是native方法，这个计时器值为空(undefined)。</p>
<p><strong>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError异常的区域。</strong></p>
<h1 id="JVM栈-JVM-Stacks"><a href="#JVM栈-JVM-Stacks" class="headerlink" title="JVM栈(JVM Stacks)"></a>JVM栈(JVM Stacks)</h1><p>与程序计数器一样，Java虚拟机栈(java virtual machine stacks)也是线程私有的，<strong>它的生命周期与线程相同，虚拟机栈描述的是Java方法执行的内存模型</strong>，每个方法被执行的时候都会同时创建一个栈桢(stack frame)用于存储局部变量表，操作栈，动态链接，方法出口等信息，** 每一个方法被调用直至执行完成的过程，对应着一个栈桢在虚拟机栈中从入栈到出栈的过程。**<br>局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(referencel类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始值的引用指针，也可能是指向一个代表对象地址的句柄或者其它与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)。</p>
<p>其中64位长度的long和double类型的数据会占用2个局部变量空间(slot)，其余的数据类型只占用1个slot，局部变量表所需要的内存空间在编译期完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量表空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<p>栈这种数据结构，特点是后进先出(LIFO)， 栈中的数据元素就是栈桢。下图就是栈桢这样数据在java栈中的结构图</p>
<p><img src="https://wenshixin.gitee.io/blog/2018/08/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%A0%88%E5%B8%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" loading="lazy"></p>
<p>在java虚拟机规范中，对这个区域规范了两种异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展(当前大部分java虚拟机都是动态可扩展的，只不过java虚拟机规范中也允许固定长度的虚拟机栈)，当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。</p>
<h1 id="本地方法栈-Native-Method-Stacks"><a href="#本地方法栈-Native-Method-Stacks" class="headerlink" title="本地方法栈(Native Method Stacks)"></a>本地方法栈(Native Method Stacks)</h1><p>本地方法栈(native method stacks)与虚拟机栈所发挥的作用是非常相似的，其区别不够是虚拟机栈为虚拟机执行java方法(也就是字节码)服务，而本地方法栈则是为虚拟机提供调用native方法的服务。虚拟机规范中对本地方法栈中的方法使用的语言，使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它，甚至有的虚拟机(譬如Hotspot虚拟机)直接就把本地方法栈和虚拟机栈合二为一，与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><p>直接内存并不在Java虚拟机管理的内存区域内，也不是Java虚拟机规范中定义的内存区域，直接内存是java程序不经过java虚拟机分配，直接使用外部主机的物理内存，这在一些场景中(如文件复制)可能提高性能，但是在使用过程中，也需要注意内存大小的限制(包括物理和系统级的限制)，否则也会抛出OutOfMemoryError异常。</p>
<h1 id="内存异常"><a href="#内存异常" class="headerlink" title="内存异常"></a>内存异常</h1><p>虽然说有Java虚拟机帮助我们管理内存，但在管理过程中仍然有内存异常发生的可能，具体的说就是，除了前面内存划分中说到的程序计数器外，其他区域都有OutOfMemoryError异常发生的可能。</p>
<p>我们可以给java虚拟机设置参数来模拟这些异常的发生，不同的java虚拟机运行结果可能不同，这里使用的是orcale公司的虚拟机。</p>
<blockquote>
<p>特别说明：下面如果没有特殊说明，默认使用的是JDK8的虚拟机</p>
</blockquote>
<h2 id="java堆内存异常"><a href="#java堆内存异常" class="headerlink" title="java堆内存异常"></a>java堆内存异常</h2><p>Java堆是用于存储对象实例的，所以只要不断地创建对象，来把java堆区域填满，并且保证垃圾回收机制不能清除这些对象，就可以模拟出java堆内存的异常。</p>
<p>模拟程序代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟java堆内存异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOM</span> &#123;</span><br><span class="line">    <span class="comment">// 声明静态内部类，声明周期和外部类一样，使垃圾收集器无法回收这些对象占用的内存空间</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OOMObject</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args &#123;</span></span><br><span class="line"><span class="params">        List&lt;OOMObject&gt; objs = new ArrayList&lt;&gt;()</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            objs.add(<span class="keyword">new</span> <span class="title class_">OOMObject</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用MAT(Memory Analyzer Tools)内存分析插件来对内存异常进行分析，IDE使用的是Eclipse，当然idea可以是可以安装的。</p>
<p>在eclipse的debug配置页面，设置jvm参数</p>
<p><img src="https://wenshixin.gitee.io/blog/2018/08/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Debug%E8%AE%BE%E7%BD%AE.jpg" loading="lazy"></p>
<p>jvm debug参数设置如下：<br>-verbose:gc -Xms20M -Xmx20M -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError -XX:+HeapDumpPath&#x3D;D:\workspace\java\dump</p>
<p>参数说明：</p>
<p>-Xms和-Xmx参数表示的是设置java堆的最小值和最大值，这里都是20M，-XX后面可以添加一些额外的设置，PrintGCDetails表示打印出来垃圾收集时的详细信息，HeapDumpOnOutOfMemoryError表示发送OutOfMemoryError错误时记录内存快照，HempDumpPath后面是存放内存快照文件的地址。</p>
<p>debug结果如下：</p>
<p><img src="https://wenshixin.gitee.io/blog/2018/08/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Java%E5%A0%86%E5%BC%82%E5%B8%B8%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg" loading="lazy"></p>
<p>从上图中可以看出，java堆内存(Heap space)出现了OutOfMemoryError的错误，并且在我们指定的文件夹中生成了内存异常时的快照文件，在使用MAT内存分析工具之前，我们还要知道内存溢出和内存泄漏的区别。我们在前面没有将OutOfMemoryError错误翻译成内存泄漏或内存异常错误。而是使用原本的英文，也是为了准确性考虑，因为内存泄漏和内存溢出都只是导致异常出血的原因，该事情的结果才产生了OutOfMemoryError错误。</p>
<p><strong>内存泄漏和内存溢出的区别：</strong></p>
<ul>
<li>内存泄漏是指程序员在申请内存后，无法释放已申请的内存空间，内存泄漏会导致内存资源耗光，通俗的说就是对象站着内存空间无法归还给系统。</li>
<li>内存溢出是指程序员申请内存使用时，发现内存空间不能满足使用，很常见的例子就是在存一个很大数时超过了该数值类型的最大值，通俗的说就是程序使用内存空间时发现无法满足自己的要求。</li>
</ul>
<p>知道了内存泄漏和内存溢出的区别，我们再来使用MAT工具分析内存快照，首先调出MAT视图，然后在&quot;File&quot;选项中选择&quot;Open Heap Dump&quot;打开内存快照文件。</p>
<p><img src="https://wenshixin.gitee.io/blog/2018/08/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%B0%83%E5%87%BAMAT%E8%A7%86%E5%9B%BE.jpg" loading="lazy"><br><img src="https://wenshixin.gitee.io/blog/2018/08/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%89%93%E5%BC%80%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7%E6%96%87%E4%BB%B6.jpg" loading="lazy"></p>
<p>打开快照文件后，可以清晰的看出内存异常问题存在的地方(problem suscept)。</p>
<p><img src="https://wenshixin.gitee.io/blog/2018/08/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7.jpg" loading="lazy"></p>
<p>点击Details可以看出具体的细节。</p>
<p><img src="https://wenshixin.gitee.io/blog/2018/08/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%85%B7%E4%BD%93%E7%BB%86%E8%8A%82.jpg" loading="lazy"></p>
<p>可以看到OOMOnject占用的内存空间很大，查看该对象是否有到GC Roots的引用链，导致垃圾收集器无法回收对象占用的内存空间。这里可以看到由于内存空间被占用后无法回收导致的OutOfMemoryError异常，异常产生的原因是内存泄漏。</p>
<p><img src="https://wenshixin.gitee.io/blog/2018/08/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%9F%A5%E7%9C%8B%E6%B3%84%E9%9C%B2%E5%AF%B9%E8%B1%A1%E5%88%B0GCRoots%E7%9A%84%E5%BC%95%E7%94%A8%E9%93%BE.gif" loading="lazy"></p>
<h2 id="栈内存异常"><a href="#栈内存异常" class="headerlink" title="栈内存异常"></a>栈内存异常</h2><p>在Hotspot虚拟机中并不区分java虚拟机栈和本地方法栈，栈的容量可以通过-Xss参数来设定。</p>
<p>在java虚拟机规范中描述了两种栈出现的异常：</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常。</li>
<li>如果虚拟机栈在动态扩展时无法申请到足够的内存，抛出OutOfMemoryError异常。</li>
</ul>
<p>栈的深度是由栈的内存空间决定的，请求的栈越深，也即是已经使用栈空间占用越大，所以上面规定的两种异常都是有重叠之处的，一种异常也可能会导致另外一种异常的发生，到底是栈的内存空间大小引起的内存异常还是已使用的栈内存空间太大引起的内存异常。</p>
<p>减少栈内存的容量和定义大量的局部变量来增加栈桢中局部变量表的长度，在理论上都是可以产生StackOverflowError异常和OutOfMemory异常的。</p>
<p>但是下面的代码只能产生StackOverflowError异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈StackOverflowError异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JVMStackSOF</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">stackLength</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stackLeak</span><span class="params">()</span> &#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        </span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">JVMStackSOF</span> <span class="variable">sof</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JVMStackSOF</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sof.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>debug的参数为：-verbose:gc -Xss128K -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError -XX:+HeapDumpPath&#x3D;D:\worksapce\java\dump</p>
<p>debug结果如下：只产生了StackOverflowError异常。</p>
<p><img src="https://wenshixin.gitee.io/blog/2018/08/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%A0%88%E5%BC%82%E5%B8%B8%E7%BB%93%E6%9E%9C1.jpg" loading="lazy"></p>
<p>而在多线程环境中测试，才可以模拟出OutOfMemoryError异常。</p>
<p><strong>特别提醒：此代码运行时会导致系统假死，具有一定的风险性，请在运行前保存好其他文件。</strong></p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 栈OutOfMemoryError异常</span><br><span class="line">public class JVMStackOOM &#123;</span><br><span class="line">    private void dontStop() &#123;</span><br><span class="line">        while(true)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 危险代码请勿随便尝试</span><br><span class="line">    public void stackLeakByThread() &#123;</span><br><span class="line">        // 死循环不断创建线程</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            new Thread(()-&gt; doneStop()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        JVMStackOOM oom = new JVMStackOOM();</span><br><span class="line">        oom.stackLeakByThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于在做这项危险的测试时，系统死掉了，所以笔者并没有得出实际结果，根据&lt;&lt;深入理解java虚拟机：JVM高级特性和最佳实践&gt;&gt;，这里给出理论结果，也可以在虚拟机系统中尝试运行此代码，但也可能会出现外部系统假死的情况，读者可以自己去尝试。</p>
<p><img src="https://wenshixin.gitee.io/blog/2018/08/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%A0%88%E5%BC%82%E5%B8%B8%E7%BB%93%E6%9E%9C2.jpg" loading="lazy"></p>
<h2 id="方法区内存异常"><a href="#方法区内存异常" class="headerlink" title="方法区内存异常"></a>方法区内存异常</h2><p>方法区有运行时常量池，如果向常量池中添加大量的内容，就可以导致方法区内存异常，可以通过-XX:PermSize和-XX:MaxPermSize来限制方法区的大小，进而限制常量池的容量，常量池在编译期可以放入常量，在运行时可以再添加新的常量，因为不存在内存被占用无法回收，所以这里的异常不是内存泄漏导致的，而是内存溢出。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuntimeConstantPoolOOM</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span> &#123;</span><br><span class="line">        List&lt;String&gt; strs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(String.of(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过实际测试，发现JDK6会出现下面内存异常的情况，而在JDK7和JDK8中，发现垃圾收集器会不断的回收常量池的旧常量所占用的内存，以便新的常量可以进入，从而避免了常量池内存异常发生，这说明新版本的JDK对这部分做了优化。</p>
<p><img src="https://wenshixin.gitee.io/blog/2018/08/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%96%B9%E6%B3%95%E5%8C%BA%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%86%85%E5%AD%98%E5%BC%82%E5%B8%B8.jpg" loading="lazy"></p>
<p>方法区用来存放类的相关信息，如类名，访问修饰符，常量池，字段描述，方法描述等，是方法区内存异常的大致思路是产生大量的类填满方法区，直到方法区内存溢出。由于实验操作起来比较麻烦。可以通过字节码增强技术，直接操作字节码来动态的生成大量的类，比较没有测试过，所以这里也是使用书中的运行结果。</p>
<p><img src="https://wenshixin.gitee.io/blog/2018/08/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%96%B9%E6%B3%95%E5%8C%BA%E5%86%85%E5%AD%98%E5%BC%82%E5%B8%B8.jpg" loading="lazy"></p>
<h2 id="直接内存异常"><a href="#直接内存异常" class="headerlink" title="直接内存异常"></a>直接内存异常</h2><p>直接内存的大小可以通过 -XX:MaxDirectMemorySize来指定，如果不指定默认是和java堆的最大值(-Xmx)一样，可以通过使用Unsafe类申请内存，有该类的使用限制，只有引导类的加载器才会返回对象实例，所以只能通过反射来获取Unsafe类的实例，但是在Eclipse中导入该类的包会报错，解决方法参考文章</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb2NoYW5nbGlhbmcxNTkvYXJ0aWNsZS9kZXRhaWxzLzUwNTU2Nzcy">elipse中解决import sun.misc.Unsafe报错的方法<i class="fa fa-external-link-alt"></i></span></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟自己内存异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectMemoryOOM</span> &#123;</span><br><span class="line">    pivate <span class="keyword">static</span> <span class="type">final</span> <span class="variable">_1Mb</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">safe</span> <span class="operator">=</span> (Unsafe)field.get(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 申请内存</span></span><br><span class="line">            safe.allocateMemory(_1Mb);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>debug参数： -verbose:gc -Xmx20M -Xms20M -XX:MaxDirectMemorySize&#x3D;100M -XX:+PrintGCDetails</p>
<p>由于在eclipse中使用jdk1.6和jdk1.7运行该程序时会直接闪退，无法得到输出的异常，所以直接在控制台中使用jdk1.8编译运行该程序。运行结果如下：</p>
<p><img src="https://wenshixin.gitee.io/blog/2018/08/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E5%BC%82%E5%B8%B8.jpg" loading="lazy"></p>
<p><strong>注意：模拟内存异常是一件危险的事情，所以务必在测试前保存好各种文件，以免造成文件内容丢失.</strong></p>
<h1 id="JVM那个区域出现的OutOfMemoryError"><a href="#JVM那个区域出现的OutOfMemoryError" class="headerlink" title="JVM那个区域出现的OutOfMemoryError"></a>JVM那个区域出现的OutOfMemoryError</h1><p>对内存结构清晰的认识同样可以帮助理解不同的OutOfMemoryError：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span>: java.lang.OutOfMemoryError: java heap space</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>原因：</strong> 对象不能分配到堆内存中</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span>: java.lang.OutOfMemoryError: PerGen space</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>原因：</strong> 类或方法不能被加载到持久代，他可能出现在一个程序加载很多类的时候，比如引用了很多第三方的库；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span>: java.lang.OutOfMemoryError：Requested array size exceeds VM limit</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>原因：</strong> 创建的数组大于堆内存的空间</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span>：java.lang.OutOfMemoryError：request &lt;size&gt; bytes <span class="keyword">for</span> &lt;reason&gt;，Out of swap space?</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>原因：</strong> 本地方法内存分配失败，JNI，本地库和java虚拟机都会从本地堆中分配内存空间。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span>：java.lang.OutOfMemoryError：&lt;reason&gt; &lt;satck trace&gt;(navite method)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>原因：</strong> 同样也是本地方法内存分配失败，只不过是JNI或者本地方法或者java虚拟机发现</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://theme-next.js.org/jvm/2018-04-01-JVM%E7%B3%BB%E5%88%97%E4%B9%8Bjava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.svg">
      <meta itemprop="name" content="yangpengbing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦彤blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 亦彤blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/jvm/2018-04-01-JVM%E7%B3%BB%E5%88%97%E4%B9%8Bjava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">JVM系列之java类加载机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-01 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-01T00:00:00+08:00">2018-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>类加载机制的奥妙</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/jvm/2018-04-01-JVM%E7%B3%BB%E5%88%97%E4%B9%8Bjava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://theme-next.js.org/java/2017-07-13-java%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.svg">
      <meta itemprop="name" content="yangpengbing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦彤blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 亦彤blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/java/2017-07-13-java%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" class="post-title-link" itemprop="url">java线程池ThreadPoolExecutor的工作原理与源码解读</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-07-13 00:00:00" itemprop="dateCreated datePublished" datetime="2017-07-13T00:00:00+08:00">2017-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" itemprop="url" rel="index"><span itemprop="name">线程池</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>随着cpu核数越来越多，不可避免的利用多线程技术以充分利用其计算能力，所以多线程技术是服务端开发人员必须掌握的技术。</p>
<p>随着线程的创建和销毁，都涉及到系统的调用，比较消耗系统资源，所以就引入了线程池技术,避免频繁的创建和销毁线程。</p>
<p>在我们的开发中&quot;池&quot;的概念并不罕见，有数据库连接池，线程池，对象池，常量池等等。</p>
<p>在java中有一个Executors工具类，可以为我们创建一个线程池，其本质就是new一个ThreadPoolExecutor对象。线程池几乎也是面试题必考的问题。本文结合源码，说说ThreadPoolExecutor的工作原理。</p>
<h1 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h1><ol>
<li>降低资源消耗</li>
</ol>
<p>可以重复利用以创建的线程，降低线程创建和销毁造成的系统资源消耗。</p>
<ol start="2">
<li>提高响应速度</li>
</ol>
<p>当任务达到时，任务可以不需要等待线程创建完就立即执行。</p>
<ol start="3">
<li>提高线程的可管理性</li>
</ol>
<p>线程是稀缺资源，如果无限的创建，不仅回消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配，调优和监控。</p>
<h1 id="线程池创建"><a href="#线程池创建" class="headerlink" title="线程池创建"></a>线程池创建</h1><p>先看一下ThreadPoolExecutor参数最全的构造方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, </span></span><br><span class="line"><span class="params">                            <span class="type">int</span> maximumPoolSize, </span></span><br><span class="line"><span class="params">                            <span class="type">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, </span></span><br><span class="line"><span class="params">                            ThreadFactory threadFactory, </span></span><br><span class="line"><span class="params">                            RejectedExceptionHandler handler)</span>&#123;</span><br><span class="line">  	</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>corePoolSize： 线程池中的核心线程数，说白了就是，即便是线程池里没有任何任务，也会有corePoolSize个线程在候着等任务。</li>
<li>maximumPoolSize： 最大线程数，不管你提交多少任务，线程池里最多工作线程就是maximumPoolSize。</li>
<li>keepAliveTime： 线程的存活时间。当线程池里的线程数大于corePoolSize时，如果登陆keepAliveTime时长还没有任务执行，则线程退出。</li>
<li>unit： 这个是用来指定keepAliveTime的单位，比如秒：TimeUnit.SECONDS。</li>
<li>workQueue： 一个阻塞队列，提交的任务将会被放入到这个队列里。</li>
<li>threadFactory：线程工厂，用来创建线程，主要是为了给线程命名，默认工厂的线程名：pool-1-thread-3。</li>
<li>handler：拒绝策略，当线程池里线程被耗尽了，且队列也满了的时候会调用。</li>
</ol>
<p>上面就是创建线程池用到的参数的详细解释。</p>
<h2 id="线程池饱和策略"><a href="#线程池饱和策略" class="headerlink" title="线程池饱和策略"></a>线程池饱和策略</h2><p>这里提到了线程池饱和策略，那我们就简单介绍下有哪些饱和策略：</p>
<ul>
<li><strong>AbortPolicy</strong></li>
</ul>
<p>为java线程池默认的阻塞策略，不执行此任务，而且直接抛出一个运行时异常，切记ThreadPoolExecutor.execute需要try catch，否则程序直接退出。</p>
<ul>
<li><strong>DiscardPolicy</strong></li>
</ul>
<p>直接抛弃，任务不执行，空方法。</p>
<ul>
<li><strong>DiscardOldestPolicy</strong></li>
</ul>
<p>从队列里抛弃head的一个任务，并再次execute此task。</p>
<ul>
<li><strong>CallerRunsPolicy</strong></li>
</ul>
<p>在调用execute的线程里面执行此command，会阻塞入口。</p>
<ul>
<li><strong>用户自定义拒绝策略(最常用)</strong></li>
</ul>
<p>实现RejectedExceptionHandler，并自己自定义拒绝策略。</p>
<h2 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h2><p>首先，线程池是一个有状态的对象，状态有以下几种:</p>
<ul>
<li><strong>RUNNING:</strong> 运行中，此时线程池能接受任务，并且会处理队列中的任务。</li>
<li><strong>SHUTDOWN:</strong> 关闭中，此时，线程池不再接受新任务，但是会处理队列中的任务。</li>
<li><strong>STOP:</strong> 停止，此时线程池不接受新任务，不会处理队列中任务，还会中断worker线程。</li>
<li><strong>TIDYING:</strong> 清理中，所有任务都已经终止且线程数等于0，开始调用terminated()。</li>
<li><strong>TERMINATED:</strong> 终止，terminated()执行结束。</li>
</ul>
<p>线程池的状态变化方式如下图所示：</p>
<p>&#x2F;&#x2F; TODO</p>
<h1 id="线程池执行流程"><a href="#线程池执行流程" class="headerlink" title="线程池执行流程"></a>线程池执行流程</h1><p>这里用一个图来说明线程池的执行过程。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14423059-6fbfbb7273dd48a7.png" loading="lazy"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14423059-22cd81af7f72ef15.png" loading="lazy"></p>
<ol>
<li>任务被提交到线程池，如果当前运行的线程数小于corePoolSize，则创建新的线程来执行任务。(注意，执行这一步骤需要获取全局锁)。</li>
<li>如果运行的线程数等于或者大于corePoolSize，则将任务添加到BlockingQueue队列中。</li>
<li>如果无法将任务加入到BlockingQueue(队列已满)，则在非corePoolSize中创建新的线程来处理任务。(注意，执行这一步骤需要获取全局锁)。</li>
<li>如果创建新线程使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectExceptionHandler.rejectedExecution()方法。</li>
</ol>
<p>ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁(这是一个严重的可伸缩瓶颈)。在ThreadPoolExecutor完成预热之后(当前运行的线程数大于等于corePoolSize)，几乎所有的execute()方法调用都是执行步骤2，而步骤2是不需要获取全局锁的。</p>
<p><strong>注意:</strong> 在每两个操作之间都要重新判断线程池的状态和线程数(中间有其他操作)，这样才能保证ThreadPoolExecutor的线程安全性。</p>
<h2 id="线程池的内部组件"><a href="#线程池的内部组件" class="headerlink" title="线程池的内部组件"></a>线程池的内部组件</h2><h2 id="Worker线程的执行逻辑"><a href="#Worker线程的执行逻辑" class="headerlink" title="Worker线程的执行逻辑"></a>Worker线程的执行逻辑</h2><p>线程池使用worker线程从队列中取任务执行，worker不断从队列中获取任务然后执行，worker线程的执行代码中还包含一些性能优化措施和容错逻辑，比如，第一任务直接放在worker中而不是放入队列中(所以worker每次都先看firstTask是否非空)，任务代码抛异常导致线程终止后，会重新创建一个线程替代挂掉的这个线程等(将processWorkerExit方法的代码)。根据对ThreadPoolExecutor.runWorker代码的分析，得出worker的执行逻辑如下图所示：</p>
<h2 id="如何判断worker线程是否空闲，如何区分核心线程和非核心线程"><a href="#如何判断worker线程是否空闲，如何区分核心线程和非核心线程" class="headerlink" title="如何判断worker线程是否空闲，如何区分核心线程和非核心线程"></a>如何判断worker线程是否空闲，如何区分核心线程和非核心线程</h2><h2 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h2><p>worker线程执行任务前后分别调用beforeExecute()和afterExecute()。</p>
<p>线程池在关闭之后会调用terminated()。</p>
<p>若要监控线程池状态，getPoolSize()，getActiveCount()，getLargestPoolSize()，getTaskCount，getCompletedTaskCount()。</p>
<p>这里以&quot;1.8.0_171&quot;的源代码为例，看一下具体实现。</p>
<ol>
<li>先看一下线程池的execute方法</li>
</ol>
<p>添加任务到线程池的核心方法execute()的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executes the given task sometime in the future.  The task</span></span><br><span class="line"><span class="comment"> * may execute in a new thread or in an existing pooled thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the task cannot be submitted for execution, either because this</span></span><br><span class="line"><span class="comment"> * executor has been shutdown or because its capacity has been reached,</span></span><br><span class="line"><span class="comment"> * the task is handled by the current &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command the task to execute</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException at discretion of</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;, if the task</span></span><br><span class="line"><span class="comment"> *         cannot be accepted for execution</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> command&#125; is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">     * 翻译如下：</span></span><br><span class="line"><span class="comment">     * 如果运行的线程数小于corePoolSize，则尝试以入参任务作为第一个任务启动一个新的线程。</span></span><br><span class="line"><span class="comment">     * 对addWorker的调用以原子性方式检查runState和workerCount,</span></span><br><span class="line"><span class="comment">     * 通过返回false防止在不应该添加线程时添加线程的错误警报。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     * 翻译如下：</span></span><br><span class="line"><span class="comment">     * 如果上一步没有完成任务提交，状态为运行并且任务可以成功添加到队列，</span></span><br><span class="line"><span class="comment">     * 那么我们仍然需要再次检查，如果状态在任务加入队列后变成非运行(可能是执行到这里线程池shutdown了)</span></span><br><span class="line"><span class="comment">     * 非运行状态下，需要reject； 然后在判断当前线程数是否为0(有可能这个时候线程数变成了0)，</span></span><br><span class="line"><span class="comment">     * 如果是，新增一个线程；</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     * 翻译如下：</span></span><br><span class="line"><span class="comment">     * 如果我们不能对任务添加到队列，那么我们尝试添加一个新的线程，如果失败了，</span></span><br><span class="line"><span class="comment">     * 则是线程池已经shutdown或者线程池已经达到饱和状态了，应该reject这个任务。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">// 工作线程数小于核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 直接启动新线程，true表示会再次检查workerCount是否小于corePoolSize</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果工作线程数大于或等于核心线程数</span></span><br><span class="line">    <span class="comment">// 线程的状态为running并且队列未满</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 再次检查线程的的运行状态，如果不是running直接从队列中移除。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 如果线程池状态为shutdown状态，需要将刚刚放入队列中的任务从队列中移除(因为突然发生的shutdown()调用)</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">// 移除成功,拒绝该非运行的任务。</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 防止了shutdown状态下没有活动线程了，但是队列还有任务没有执行的特殊情况。</span></span><br><span class="line">            <span class="comment">// 添加一个null任务是因为shutdown状态下，线程池不再接受新任务</span></span><br><span class="line">            <span class="comment">// 需要重新在创建一个worker线程(因为检查过的核心线程正好挂掉，如果不创建worker则线程池此时进入静止状态)</span></span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果放入阻塞队列失败，这创建非核心worker线程处理给任务</span></span><br><span class="line">    <span class="comment">// 如果队列满了，workerCount大于等于maximumPoolSize，则创建worker线程失败，则将任务交给饱和策略(handler)处理。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/14423059-c8c8b02a0eb9028a.png" loading="lazy"></p>
<p>①. 判断当前活跃线程数是否小于corePoolSize，如果小于，则调用addWorker创建线程执行任务<br><br>②. 如果不小于corePoolSize，则将任务添加到workQueue队列中。<br><br>③. 如果放入workeQueu失败，则创建线程执行任务，如果创建线程失败(当前线程数不小于maximumPoolSize时)，就会调用reject(内部调用handler)拒绝接受任务。</p>
<ol start="2">
<li>再看下addWorker的方法实现</li>
</ol>
<p>addWorker的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks if a new worker can be added with respect to current</span></span><br><span class="line"><span class="comment"> * pool state and the given bound (either core or maximum). If so,</span></span><br><span class="line"><span class="comment"> * the worker count is adjusted accordingly, and, if possible, a</span></span><br><span class="line"><span class="comment"> * new worker is created and started, running firstTask as its</span></span><br><span class="line"><span class="comment"> * first task. This method returns false if the pool is stopped or</span></span><br><span class="line"><span class="comment"> * eligible to shut down. It also returns false if the thread</span></span><br><span class="line"><span class="comment"> * factory fails to create a thread when asked.  If the thread</span></span><br><span class="line"><span class="comment"> * creation fails, either due to the thread factory returning</span></span><br><span class="line"><span class="comment"> * null, or due to an exception (typically OutOfMemoryError in</span></span><br><span class="line"><span class="comment"> * Thread.start()), we roll back cleanly.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 检查是否可以根据当前线程池状态和给定的边界(核心和最大值)添加新woker</span></span><br><span class="line"><span class="comment"> * 如果是，则worderCount将相应的进行调整，如果可能，将创建比启动一个新的worker</span></span><br><span class="line"><span class="comment"> * 运行firstTask作为其第一个任务，如果线程池被停止或者被shutdown，该方法返回false</span></span><br><span class="line"><span class="comment"> * 如果线程工厂在被请求的时候，创建线程失败，也会返回false</span></span><br><span class="line"><span class="comment"> * 如果创建线程失败，要么是由于线程工厂返回null，要么是由于异常(通常是thread.start()中的OutOfMemoryError)</span></span><br><span class="line"><span class="comment"> * 我们将干净地回滚。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstTask the task the new thread should run first (or</span></span><br><span class="line"><span class="comment"> * null if none). Workers are created with an initial first task</span></span><br><span class="line"><span class="comment"> * (in method execute()) to bypass queuing when there are fewer</span></span><br><span class="line"><span class="comment"> * than corePoolSize threads (in which case we always start one),</span></span><br><span class="line"><span class="comment"> * or when the queue is full (in which case we must bypass queue).</span></span><br><span class="line"><span class="comment"> * Initially idle threads are usually created via</span></span><br><span class="line"><span class="comment"> * prestartCoreThread or to replace other dying workers.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 新线程应该首先运行的任务(如果没有线程，则为null)。当线程数量少于corePoolSize线程时(在方法execute()中)，</span></span><br><span class="line"><span class="comment"> * 或者当队列已满时(在这种情况下，我们必须绕过队列)，将使用一个初始化first task创建worker，</span></span><br><span class="line"><span class="comment"> * 初始空闲线程通常是通过prestartCoreThread创建的或者同来替换其他垂死的worker。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> core if true use corePoolSize as bound, else</span></span><br><span class="line"><span class="comment"> * maximumPoolSize. (A boolean indicator is used here rather than a</span></span><br><span class="line"><span class="comment"> * value to ensure reads of fresh values after checking other pool</span></span><br><span class="line"><span class="comment"> * state).</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 如果为true，使用corePoolSize作为边界，否则使用maximumPoolSize为边界，</span></span><br><span class="line"><span class="comment"> * (这里使用boolean作为指示符，而不是使用value，以确保在检查其他线程池状态后读取新值)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    <span class="comment">// java标签</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">// 死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 获取当前线程状态 (running为-536870912，shutdown为0，stop为536870912，tidying为1073741824，terminated为1610612736)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">// 这个逻辑判断有点绕可以改成</span></span><br><span class="line">        <span class="comment">// rs &gt;= SHUTDOWN &amp;&amp; (rs != SHUTDOWN || firstTask != null || workQueue.isEmpty())</span></span><br><span class="line">        <span class="comment">// 逻辑判断成立可以分为下面几种情况均不接受新任务</span></span><br><span class="line">        <span class="comment">// 1. rs &gt; shutdown;  --&gt;不接受新任务</span></span><br><span class="line">        <span class="comment">// 2. rs &gt;= shutdown &amp;&amp; firstTask != null; --&gt;不接受新任务</span></span><br><span class="line">        <span class="comment">// 3. rs &gt;= shutdown &amp;&amp; workQueue.isEmpty(); --&gt;不接受新任务</span></span><br><span class="line">        <span class="comment">// 逻辑判断不成立</span></span><br><span class="line">        <span class="comment">// 1. rs == shutdown &amp;&amp; firstTask != null; 此时不会接受任务，但是仍然会执行队列中的任务</span></span><br><span class="line">        <span class="comment">// 2. rs == shutdown &amp;&amp; firstTask == null; 会执行addWorker(null, false)</span></span><br><span class="line">        <span class="comment">// 防止了SHUTDOWN状态下没有活动线程了，但是队列里还有任务没有执行这种特殊情况</span></span><br><span class="line">        <span class="comment">// 添加了一个null任务是因为SHUTDOWN状态下，线程池不再接受新任务</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 死循环</span></span><br><span class="line">        <span class="comment">// 如果线程池状态为running并且队列中还有需要执行的任务。</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取线程池中的线程数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">            <span class="comment">// 如果超出容量或者最大线程池容量不再接受新任务</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 原子操作增加工作线程数</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="comment">// 跳出retry</span></span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 如果线程池状态发生变化，重新循环</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行到这里说明工作线程数增加成功。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">// running状态 || shutdown状态下清理队列中的剩余任务。</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 检查线程状态</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                    <span class="comment">// 将新启动的线程添加到线程池中</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="comment">// 更新线程池数量数且不超过最大值</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 启动新添加的线程，这个线程首先执行firstTask，然后不停的从队列中取任务执行</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 执行ThreadPoolExecutor的runWorker方法</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 线程启动失败，这从workers中移除w并递减workerCount</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            <span class="comment">// 递减workerCount会tryTerminate方法</span></span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/14423059-330bdc6ab704c2da.png" loading="lazy"></p>
<p>这块代码是在创建非核心线程时，即core为false。判断当前线程数是否大于等于maximumPoolSize，如果大于等于则返回false，即上边说到③中的创建线程失败的情况。</p>
<p>addWorker方法的下半部分：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14423059-8face7330471f805.png" loading="lazy"></p>
<p>①. 创建Worker对象，用时也会实例化一个Thread对象。<br><br>②. 启动这个线程</p>
<p>adWorker之后是runWorker，第一次启动会执行初始化传递过来的firstTask；然后会从workerQueue中取任务执行，如果队列为空则等待keepAliceTime这么长时间。</p>
<ol start="3">
<li>再到Woker里面看看其实现</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/14423059-8a11d5489dd2a180.png" loading="lazy"></p>
<p>可以看到在创建Worker时会调用threadFactory来创建一个线程，上面②中启动一个线程就会触发worker的run方法被线程调用。Worker实现了Runable接口。这里使用了委派设计模式</p>
<ol start="4">
<li>接下来看看runWorker方法的逻辑</li>
</ol>
<p>runWorker源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main worker run loop.  Repeatedly gets tasks from queue and</span></span><br><span class="line"><span class="comment"> * executes them, while coping with a number of issues:</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * main worker循环运行，从队列中反复获取task并执行它们，同时处理许多问题：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. We may start out with an initial task, in which case we</span></span><br><span class="line"><span class="comment"> * don&#x27;t need to get the first one. Otherwise, as long as pool is</span></span><br><span class="line"><span class="comment"> * running, we get tasks from getTask. If it returns null then the</span></span><br><span class="line"><span class="comment"> * worker exits due to changed pool state or configuration</span></span><br><span class="line"><span class="comment"> * parameters.  Other exits result from exception throws in</span></span><br><span class="line"><span class="comment"> * external code, in which case completedAbruptly holds, which</span></span><br><span class="line"><span class="comment"> * usually leads processWorkerExit to replace this thread.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 1. 我们可能从一个初始任务开始，在这种情况下我们不需要获取第一个任务。</span></span><br><span class="line"><span class="comment"> * 否则，只要线程池正在运行，我们就会从getTask获取任务，如果它返回null，</span></span><br><span class="line"><span class="comment"> * 则worker由于线程池状态或配置参数的更改而退出。其他退出是由额外的代码中</span></span><br><span class="line"><span class="comment"> * 异常抛出引起的，在这种情况下，completedAbruptlyholds，通常会导致processWorkerExit替换此线程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. Before running any task, the lock is acquired to prevent</span></span><br><span class="line"><span class="comment"> * other pool interrupts while the task is executing, and then we</span></span><br><span class="line"><span class="comment"> * ensure that unless pool is stopping, this thread does not have</span></span><br><span class="line"><span class="comment"> * its interrupt set.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 2. 在运行任何任务之前，获取锁以防止执行时其线程池中断，然后我们</span></span><br><span class="line"><span class="comment"> * 确保出发线程池停止，否则此线程没有设置设置中断。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. Each task run is preceded by a call to beforeExecute, which</span></span><br><span class="line"><span class="comment"> * might throw an exception, in which case we cause thread to die</span></span><br><span class="line"><span class="comment"> * (breaking loop with completedAbruptly true) without processing</span></span><br><span class="line"><span class="comment"> * the task.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 3. 每个任务运行之前都会调用beforeExecute，可能会抛出异常，</span></span><br><span class="line"><span class="comment"> * 在这种情况下，我们会导致线程死掉(使用completedAbruptly打开循环为true)而不处理任务。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. Assuming beforeExecute completes normally, we run the task,</span></span><br><span class="line"><span class="comment"> * gathering any of its thrown exceptions to send to afterExecute.</span></span><br><span class="line"><span class="comment"> * We separately handle RuntimeException, Error (both of which the</span></span><br><span class="line"><span class="comment"> * specs guarantee that we trap) and arbitrary Throwables.</span></span><br><span class="line"><span class="comment"> * Because we cannot rethrow Throwables within Runnable.run, we</span></span><br><span class="line"><span class="comment"> * wrap them within Errors on the way out (to the thread&#x27;s</span></span><br><span class="line"><span class="comment"> * UncaughtExceptionHandler).  Any thrown exception also</span></span><br><span class="line"><span class="comment"> * conservatively causes thread to die.</span></span><br><span class="line"><span class="comment"> *  翻译如下：</span></span><br><span class="line"><span class="comment"> * 4. 假设beforeExecute正常完成，我们运行任务，收集任何抛出的异常已发送到afterExecute。</span></span><br><span class="line"><span class="comment"> * 我们分别处理RuntimeException和Error(这两种异常规范保证我们的陷阱)和任意Throwables。</span></span><br><span class="line"><span class="comment"> * 因为我们无法在Runnable.run中重新抛出Throwables，所以我们在出路的时候将它包装在</span></span><br><span class="line"><span class="comment"> * Errors中(到了线程的UncaughtExceptionHandler)。任何抛出的异常导致线程死亡。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 5. After task.run completes, we call afterExecute, which may</span></span><br><span class="line"><span class="comment"> * also throw an exception, which will also cause thread to</span></span><br><span class="line"><span class="comment"> * die. According to JLS Sec 14.20, this exception is the one that</span></span><br><span class="line"><span class="comment"> * will be in effect even if task.run throws.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 在task.run完成之后，我们将调用afterExecute，这可能也会抛出异常，</span></span><br><span class="line"><span class="comment"> * 这也会导致线程死掉，根据JLS Sec 14.20这个例外是即使task.run抛出异常也将生效。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The net effect of the exception mechanics is that afterExecute</span></span><br><span class="line"><span class="comment"> * and the thread&#x27;s UncaughtExceptionHandler have as accurate</span></span><br><span class="line"><span class="comment"> * information as we can provide about any problems encountered by</span></span><br><span class="line"><span class="comment"> * user code.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 异常机制的净效果是afterExecute和线程的UncaughtExceptionHandler有关user代码</span></span><br><span class="line"><span class="comment"> * 遇到的任何问题的准确信息。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w the worker</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 允许中断</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果getTask返回null，那么getTask中会将workerCount递减，如果异常了这个递减操作会在processWorkerExit中处理。</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/14423059-f29213e056b2f535.png" loading="lazy"></p>
<p>线程调用runWorker，会while循环调用getTask方法从workerQueue队列里读取任务，然后执行任务。只要getTask方法不返回null，此线程就不会退出。</p>
<ol start="5">
<li>在看看getTask方法实现</li>
</ol>
<p>getTask源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs blocking or timed wait for a task, depending on</span></span><br><span class="line"><span class="comment"> * current configuration settings, or returns null if this worker</span></span><br><span class="line"><span class="comment"> * must exit because of any of:</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 根据当前的配置设置，执行阻塞或定时等待task，如果因为如下的任何一个原因导致worker退出，则返回null。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. There are more than maximumPoolSize workers (due to</span></span><br><span class="line"><span class="comment"> *    a call to setMaximumPoolSize).</span></span><br><span class="line"><span class="comment"> * 2. The pool is stopped.</span></span><br><span class="line"><span class="comment"> * 3. The pool is shutdown and the queue is empty.</span></span><br><span class="line"><span class="comment"> * 4. This worker timed out waiting for a task, and timed-out</span></span><br><span class="line"><span class="comment"> *    workers are subject to termination (that is,</span></span><br><span class="line"><span class="comment"> *    &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut || workerCount &gt; corePoolSize&#125;)</span></span><br><span class="line"><span class="comment"> *    both before and after the timed wait, and if the queue is</span></span><br><span class="line"><span class="comment"> *    non-empty, this worker is not the last thread in the pool.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 1. 超过了maximumPoolSize个workers。(由于调用了setMaximumPoolSize)</span></span><br><span class="line"><span class="comment"> * 2. 线程池停止了</span></span><br><span class="line"><span class="comment"> * 3. 线程池shutdown并且队列为空</span></span><br><span class="line"><span class="comment"> * 4. worker超时等于一个task，超时的workers在超时等待之前和之后都会被终止(即，allowCoreThreadTimeOut || workerCount &gt; corePoolSize)</span></span><br><span class="line"><span class="comment"> * 如果队列不为空，那么这个worker不是这个线程池的最后一个线程。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> task, or null if the worker must exit, in which case</span></span><br><span class="line"><span class="comment"> *         workerCount is decremented</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 返回task，如果worder意外退出，返回null，在这种情况下workerCount被递减。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取线程池状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">// 1. rs &gt; shutdown, rs至少大于stop，这个时候不处理队列中的任务</span></span><br><span class="line">        <span class="comment">// 2. rs = shutdown，这个时候需要处理队列中的任务除非队列为空</span></span><br><span class="line">        <span class="comment">// 这两种情况都会返回null，让runWorker退出while循环，也就是当前线程执行完毕，所以workerCount必须递减</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">// 递减wokerCount的值</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">// 标记从队列中取任务时是否设置超时时间</span></span><br><span class="line">        <span class="comment">// 1. core thread允许被超时，那么超过corePoolSize的线程也必定允许被超时</span></span><br><span class="line">        <span class="comment">// 2. allowCoreThreadTimeOut(默认值就是false) || wc &gt; corePoolSize时，一般都是这种情况。core Thread即时空闲也不会被回收，只要超过corePoolSize的线程才会被回收。</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从addWorker可以看到一般wc是不会大于maximumPoolSize，故wc &gt; maximumPoolSize是false，所以需要关心后面半句的情形</span></span><br><span class="line">        <span class="comment">// 1. timed = false，说明wc小于corePoolSize，说明当前运行的线程数小于核心线程数，队列take();</span></span><br><span class="line">        <span class="comment">// 1. timed = true, 说明当前运行的线程数大于核心核心线程数; timedOut == false，第一次循环。从队列中取出不为空的方法返回，或者poll跑异常了重试。</span></span><br><span class="line">        <span class="comment">// 2. timed = true, timedOut == true, 说明有poll操作有超时的;  wc &gt; 1 true，如果队列中不为空，从队列中取出不为空和方法方法。如果队列为空，方法null。</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">// workerCount递减，方法null任务，接受当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 以指定的超时时间从队列中获取任务。</span></span><br><span class="line">            <span class="comment">// 2. core thread 默认没有超时</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 超时</span></span><br><span class="line">            timedOut = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">// 线程被中断重试</span></span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/14423059-ce84682cc3c8f7dd.png" loading="lazy"></p>
<p>①. 先不管allowCoreThreadTimeOut，这个变量的默认值是false，wc &gt; corePoolSize则是判断当前线程数是否大于corePoolSize。<br><br>②. 如果当前线程数大于corePoolSize，这回调用wokerQueue的poll方法获取任务，超时时间就是keepAliveTime。如果超过keepAliveTime时长，poll返回了null，上边提到的while循环就会退出，线程也就执行完了，如果当前线程数小于corePoolSize，则会调用wokerQueue的take方法阻塞在当前。</p>
<ol start="6">
<li>在看看processWorkerExit是如何工作的</li>
</ol>
<p>processWorkerExit源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs cleanup and bookkeeping for a dying worker. Called</span></span><br><span class="line"><span class="comment"> * only from worker threads. Unless completedAbruptly is set,</span></span><br><span class="line"><span class="comment"> * assumes that workerCount has already been adjusted to account</span></span><br><span class="line"><span class="comment"> * for exit.  This method removes thread from worker set, and</span></span><br><span class="line"><span class="comment"> * possibly terminates the pool or replaces the worker if either</span></span><br><span class="line"><span class="comment"> * it exited due to user task exception or if fewer than</span></span><br><span class="line"><span class="comment"> * corePoolSize workers are running or queue is non-empty but</span></span><br><span class="line"><span class="comment"> * there are no workers.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 为垂死的worker执行清理，仅仅是从worker线程中被调用的，除非设置了completedAbruptly。</span></span><br><span class="line"><span class="comment"> * 否则调整workerCount减去已经退出的账户，这个方法从woker set中移除线程，并且如果由于任务异常退出或者如果正在运行线程数小于corePoolSize</span></span><br><span class="line"><span class="comment"> * 或者队列非空但是没有worker，则可能导致线程池终止或替换worker。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w the worker</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> completedAbruptly if the worker died due to user exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span><span class="params">(Worker w, <span class="type">boolean</span> completedAbruptly)</span> &#123;</span><br><span class="line">    <span class="comment">// 正常的话再runWorker的getTask方法中workerCount已经递减过了。</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 累加的线程completedTasks</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">// 从线程池中移除超时或者出现异常的线程</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试停止线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="comment">// 线程不是异常结束</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="comment">// 线程池最小空闲数，允许core thread超时就是0，否则就是corePoolSize</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="comment">// 如果min == 0但是队列不为空要保证有1个线程来执行队列中的任务</span></span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 线程池还不为空那就不用担心了</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 线程异常退出</span></span><br><span class="line">        <span class="comment">// 2. 线程池为空，但是队列中还有任务没有执行，看addWorker方法对这种情况的处理。</span></span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>看看tryTerminate的源码</li>
</ol>
<p>processWorkerExit方法中会尝试调用tryTerminate来终止线程池，这个方法在任何可能导致线程池终止的动作后执行；比如减少workerCount或者shutdown状态下从队列中移除任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transitions to TERMINATED state if either (SHUTDOWN and pool</span></span><br><span class="line"><span class="comment"> * and queue empty) or (STOP and pool empty).  If otherwise</span></span><br><span class="line"><span class="comment"> * eligible to terminate but workerCount is nonzero, interrupts an</span></span><br><span class="line"><span class="comment"> * idle worker to ensure that shutdown signals propagate. This</span></span><br><span class="line"><span class="comment"> * method must be called following any action that might make</span></span><br><span class="line"><span class="comment"> * termination possible -- reducing worker count or removing tasks</span></span><br><span class="line"><span class="comment"> * from the queue during shutdown. The method is non-private to</span></span><br><span class="line"><span class="comment"> * allow access from ScheduledThreadPoolExecutor.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * shutdown和线程池和队列为空，或者stop和线程池为空转换为terminate状态。</span></span><br><span class="line"><span class="comment"> * 如果否则有资格终止但workerCount非零，则中断空闲worker程序以确保关闭信号传播。</span></span><br><span class="line"><span class="comment"> * 必须在任何可能是线程池终止的操作之后调用此方法，在关闭期间减少worker count或者从队列中移除任务。</span></span><br><span class="line"><span class="comment"> * 该方法是非私有的允许从ScheduledThreadPoolExecutor访问。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryTerminate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 以下状态直接返回：</span></span><br><span class="line">        <span class="comment">// 1. 线程池处于running状态</span></span><br><span class="line">        <span class="comment">// 2. runState &gt;= tidying 线程池已经停止了或者在停止。</span></span><br><span class="line">        <span class="comment">// 3. shutdown状态但是任务队列非空</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 只能是以下情形会继续下面的逻辑，结束线程池。</span></span><br><span class="line">        <span class="comment">// 1. shutdown状态，这时不在接受新任务而且队列也为空了</span></span><br><span class="line">        <span class="comment">// 2. stop状态，当调用了shutdownNow方法</span></span><br><span class="line">        <span class="comment">// workerCount不为0则还不能停止线程池，而且这时线程都处于空闲等待的状态。</span></span><br><span class="line">        <span class="comment">// 需要中断让线程醒过来，醒过来的线程才能继续处理shutdown的信号。</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            <span class="comment">// runWorker方法中w.unlock就是为了可以被中断，getTask方法也处理了中断。</span></span><br><span class="line">            <span class="comment">// ONLY_ONE; 这里只需要中断1个线程去处理shutdown信号就可以了。</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 进入tidying状态</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 子类重载，一些资源清理工作</span></span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// terminate状态</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    <span class="comment">// 继续awaitTermination</span></span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shutdown这个方法将runState设置为shutdown，会终止所有空闲的线程，shutdownNow方法将runState设置为stop。和shutdown方法的区别，这个方法会终止所有的线程。主要区别在于shutdown调用的是interrupttIdleWorkers这个方法，而shutdownNow实际上调用的是Worker类的interruptIfStarted方法：</p>
<p>shutdown源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initiates an orderly shutdown in which previously submitted</span></span><br><span class="line"><span class="comment"> * tasks are executed, but no new tasks will be accepted.</span></span><br><span class="line"><span class="comment"> * Invocation has no additional effect if already shut down.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 开始有顺序的shutdown已经执行过的task，但是不会接受新的task</span></span><br><span class="line"><span class="comment"> * 如果已经shutdown了，则调用没有额外的影响。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method does not wait for previously submitted tasks to</span></span><br><span class="line"><span class="comment"> * complete execution.  Use &#123;<span class="doctag">@link</span> #awaitTermination awaitTermination&#125;</span></span><br><span class="line"><span class="comment"> * to do that.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 此方法不需要等待以前提交的task执行完，使用awaitTermination来做它。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 线程池状态设置为shutdown，如果已经至少是这个状态那么则直接返回</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 注意这里是中断所有的空闲线程：runWorker中等待的线程被中断，进入processWorkerExit</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// tryTerminate方法中会保证队列中剩余的任务也会得到执行。</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shutdownNow源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempts to stop all actively executing tasks, halts the</span></span><br><span class="line"><span class="comment"> * processing of waiting tasks, and returns a list of the tasks</span></span><br><span class="line"><span class="comment"> * that were awaiting execution. These tasks are drained (removed)</span></span><br><span class="line"><span class="comment"> * from the task queue upon return from this method.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 尝试停止所有活跃的正在执行的task，停止等待执行的task，</span></span><br><span class="line"><span class="comment"> * 并返回等待执行的task列表，从方法返回后，这些方法将被删除。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method does not wait for actively executing tasks to</span></span><br><span class="line"><span class="comment"> * terminate.  Use &#123;<span class="doctag">@link</span> #awaitTermination awaitTermination&#125; to</span></span><br><span class="line"><span class="comment"> * do that.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 此方法不需要等待主动执行的task的终止，使用awaitTermination来完成此操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;There are no guarantees beyond best-effort attempts to stop</span></span><br><span class="line"><span class="comment"> * processing actively executing tasks.  This implementation</span></span><br><span class="line"><span class="comment"> * cancels tasks via &#123;<span class="doctag">@link</span> Thread#interrupt&#125;, so any task that</span></span><br><span class="line"><span class="comment"> * fails to respond to interrupts may never terminate.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 除了尽最大努力停止正活跃的在执行的task外，没有其他保证。</span></span><br><span class="line"><span class="comment"> * 这个实现是通过Thread.interrupt取消任务的，因此未能响应的中断的task</span></span><br><span class="line"><span class="comment"> * 可能永远不会终止。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 设置线程池为stop状态，不再接受任务且不再执行队列中的任务</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 中断所有的线程</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 返回队列中还没有执行的任务</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>interruptIdleWorkers的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interrupts threads that might be waiting for tasks (as</span></span><br><span class="line"><span class="comment"> * indicated by not being locked) so they can check for</span></span><br><span class="line"><span class="comment"> * termination or configuration changes. Ignores</span></span><br><span class="line"><span class="comment"> * SecurityExceptions (in which case some threads may remain</span></span><br><span class="line"><span class="comment"> * uninterrupted).</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 中断等待任务的线程(显示未被锁定)，以便检查终止或更改配置，</span></span><br><span class="line"><span class="comment"> * 忽略SecurityExceptions(在这种情况下，一些线程可能保持不间断)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyOne If true, interrupt at most one worker. This is</span></span><br><span class="line"><span class="comment"> * called only from tryTerminate when termination is otherwise</span></span><br><span class="line"><span class="comment"> * enabled but there are still other workers.  In this case, at</span></span><br><span class="line"><span class="comment"> * most one waiting worker is interrupted to propagate shutdown</span></span><br><span class="line"><span class="comment"> * signals in case all threads are currently waiting.</span></span><br><span class="line"><span class="comment"> * Interrupting any arbitrary thread ensures that newly arriving</span></span><br><span class="line"><span class="comment"> * workers since shutdown began will also eventually exit.</span></span><br><span class="line"><span class="comment"> * To guarantee eventual termination, it suffices to always</span></span><br><span class="line"><span class="comment"> * interrupt only one idle worker, but shutdown() interrupts all</span></span><br><span class="line"><span class="comment"> * idle workers so that redundant workers exit promptly, not</span></span><br><span class="line"><span class="comment"> * waiting for a straggler task to finish.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 如果true，最多中断一个worker，只有在启用终止时，才从tryTerminate调用这个，</span></span><br><span class="line"><span class="comment"> * 但是仍然有其他的worker，在这种情况下，在在所有线程当前都在等待的情况下，</span></span><br><span class="line"><span class="comment"> * 最多一个worker被中断以传播shutdown信号，中断任意线程，确保关闭开启后新来的</span></span><br><span class="line"><span class="comment"> * worker最终也会终止，总之，只中断一个空闲的worker就足够了，但是shutdown()中断</span></span><br><span class="line"><span class="comment"> * 所有的空闲worker，这样冗余的workers就会迅速退出，而不是等待一个掉队的任务完成。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">interruptIdleWorkers</span><span class="params">(<span class="type">boolean</span> onlyOne)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">            <span class="comment">// w.tryLock能够获到锁，说明该线程没有在运行，因为runWorker中执行任务会先lock</span></span><br><span class="line">            <span class="comment">// 因此保证了中断的肯定是空闲的线程</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Woker类中的方法interruptIfStarted源代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">interruptIfStarted</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="comment">// 初始化时state为-1</span></span><br><span class="line">    <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="literal">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://theme-next.js.org/java/2017-03-03-JDK8%E6%BA%90%E7%A0%81%E4%B9%8BHashMap%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.svg">
      <meta itemprop="name" content="yangpengbing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦彤blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 亦彤blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/java/2017-03-03-JDK8%E6%BA%90%E7%A0%81%E4%B9%8BHashMap%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">jdk8源码之HashMap深度解析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-03-03 00:00:00" itemprop="dateCreated datePublished" datetime="2017-03-03T00:00:00+08:00">2017-03-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jdk8/" itemprop="url" rel="index"><span itemprop="name">jdk8</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3d1cGVpeHVhbi9KREtTb3VyY2VDb2RlMS44L2Jsb2IvbWFzdGVyL3NyYy9qYXZhL3V0aWwvSGFzaE1hcC5qYXZh">https://github.com/wupeixuan/JDKSourceCode1.8/blob/master/src/java/util/HashMap.java<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="HashMap底层实现原理"><a href="#HashMap底层实现原理" class="headerlink" title="HashMap底层实现原理"></a>HashMap底层实现原理</h2><p>HashMap底层原理总结，几个Hash集合之间的对比。</p>
<pre><code>参考：什么是HashMap？

参考：Java 8系列之重新认识HashMap
</code></pre>
<h3 id="HashMap底层存储结构"><a href="#HashMap底层存储结构" class="headerlink" title="HashMap底层存储结构"></a>HashMap底层存储结构</h3><p>HashMap是一个用于存储Key-Value键值对的集合，每一个键值对也叫做一个Entry。这些Entry分散存储在一个数组当中，这个数组就是HashMap的主干。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment"> * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123; <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为table数组的长度是有限的，再好的hash函数也会出现index冲突的情况，所以我们用链表来解决这个问题，table数组的每一个元素不只是一个Entry对象，也是一个链表的头节点，每一个Entry对象通过Next指针指向下一个Entry节点。当新来的Entry映射到冲突数组位置时，只需要插入对应的链表即可。</p>
<p>需要注意的是：JDK1.7 新来的Entry节点插入链表时，会插在链表的头部，因为HashMap的发明者认为，后插入的Entry被查找的可能性更大。 JDK1.8是将节点查下链表的尾部，因为需要遍历链表，计算长度，插入头部，需要移动链表</p>
<p>HashMap中的table数组如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14423059-837dac531ca01daa.png" loading="lazy"></p>
<p>所以，HashMap是数组+链表+红黑树（在Java 8中为了优化Entry的查找性能，新加了红黑树部分）实现的。</p>
<h3 id="Put方法原理"><a href="#Put方法原理" class="headerlink" title="Put方法原理"></a>Put方法原理</h3><p>调用hashMap.put(&quot;str&quot;, 1)，将会在HashMap的table数组中插入一个Key为“str”的元素，这时候需要我们用一个hash()函数来确定Entry的插入位置，而每种数据类型有自己的hashCode()函数，比如String类型的hashCode()函数如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(<span class="type">byte</span>[] value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">byte</span> v : value) &#123;</span><br><span class="line">        h = <span class="number">31</span> * h + (v &amp; <span class="number">0xff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，put()函数的执行路径是这样的：</p>
<pre><code>1. 首先put(&quot;str&quot;, 1)会调用HashMap的hash(&quot;str&quot;)方法。
2. 在hash()内部，会调用String(Latin1)内部的hashcode()获取字符串”str”的hashcode。
3. “str”的hashcode被返回给put()，put()通过一定计算得到最终的插入位置index。
4. 最后将这个Entry插入到table的index位置。
</code></pre>
<p>这里就出现了两个问题，问题1: 在put()里怎样得到插入位置index？问题2: 为什么会调用HashMap的hash()函数，直接调用String的hashcode()不好吗？</p>
<h4 id="问题1-在put-里怎样得到插入位置index？"><a href="#问题1-在put-里怎样得到插入位置index？" class="headerlink" title="问题1: 在put()里怎样得到插入位置index？"></a>问题1: 在put()里怎样得到插入位置index？</h4><p>对于不同的hash码我们希望它被插入到不同的位置，所以我们首先会想到对数组长度的取模运算，但是由于取模运算的效率很低，所以HashMap的发明者用位运算替代了取模运算。</p>
<p>在put()里是通过如下的语句得到插入位置的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = hash(key) &amp; (Length - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>其中Length是table数组的长度。为了实现和取模运算相同的功能，这里要求(Length - 1)这部分的二进制表示全为1，我们用HashMap的默认初始长度16举例说明：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假设&quot;str&quot;的hash吗为: 1001 0110 1011 1110 1101 0010 1001 0101</span><br><span class="line"></span><br><span class="line">Length - 1 = 15 : 1111</span><br><span class="line"></span><br><span class="line">hash(&quot;str&quot;) &amp; (Length - 1) = 0101</span><br></pre></td></tr></table></figure>

<p>如果(Length - 1)这部分不全为1，假如Length是10，那么Length - 1 &#x3D; 9 ：1001 那么无论再和任何hash码做与操作，中间两位数都会是0，这样就会出现大量不同的hash码被映射到相同位置的情况。</p>
<p>所以，在HashMap中table数组的默认长度是16，并且要求每次自动扩容或者手动扩容时，长度都必须是2的幂。</p>
<h4 id="问题2-为什么会调用HashMap的hash-函数，直接调用String的hashcode-不好吗？"><a href="#问题2-为什么会调用HashMap的hash-函数，直接调用String的hashcode-不好吗？" class="headerlink" title="问题2: 为什么会调用HashMap的hash()函数，直接调用String的hashcode()不好吗？"></a>问题2: 为什么会调用HashMap的hash()函数，直接调用String的hashcode()不好吗？</h4><p>HashMap中的hash()函数如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap中的hash()函数是将得到hashcode做进一步处理，它将hashcode的高16位和低16位进行异或操作，这样做的目的是：在table的长度比较小的情况下，也能保证hashcode的高位参与到地址映射的计算当中，同时不会有太大的开销。</p>
<p>综上所述：从hashcode计算得到table索引的计算过程如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14423059-794edcdbedc4b7ec.png" loading="lazy"></p>
<p>put()方法的执行过程如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14423059-7935c4c7f2335cb8.png" loading="lazy"></p>
<h3 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h3><p>在HashMap中有一下两个属性和扩容相关：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<p>其中threshold &#x3D; Length * loadFactor，Length表示table数组的长度（默认值是16），loadFactor为负载因子（默认值是0.75），阀值threshold表示当table数组中存储的元素超过这个阀值的时候，就需要扩容了。以默认长度16，和默认负载因子0.75为例，threshold &#x3D; 16 * 0.75 &#x3D; 12，即当table数组中存储的元素个数超过12个的时候，table数组就该扩容了。</p>
<p>当然Java中的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，然后将旧数组中的元素经过重新计算放到新数组中，那么怎样对旧元素进行重新映射呢？</p>
<p>其实很简单，由于我们在扩容时，是使用2的幂扩展，即数组的长度扩大到原来的2倍, 4倍, 8倍…，因此在resize时(Length - 1)这部分相当于在高位新增一个或多个1bit，我们以扩大到原来的两倍为例说明：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14423059-73d0dc1f00dea165.png" loading="lazy"></p>
<p>(a)中n为16，(b)中n扩大到两倍为32，相当于(n - 1)这部分的高位多了一个1, 然后和原hash码作与操作，这样元素在数组中映射的位置要么不变，要不向后移动16个位置：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14423059-4ebc4aafe7d6808e.png" loading="lazy"></p>
<p>因此，我们在扩充HashMap的时候，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14423059-e9365ec251327548.png" loading="lazy"></p>
<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中resize的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。</p>
<h3 id="HashMap死锁形成原理"><a href="#HashMap死锁形成原理" class="headerlink" title="HashMap死锁形成原理"></a>HashMap死锁形成原理</h3><p>HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用线程安全的ConcurrentHashMap。</p>
<p>要理解HashMap死锁形成的原理，我们要对HashMap的resize里的transfer过程有所了解，transfer过程是将旧数组中的元素复制到新数组中，在Java 8之前，复制过程会导致链表倒置，这也是形成死锁的重要原因（Java 8中已经不会倒置），transfer的基本过程如下：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 新建节点e指向当前节点，新建节点next指向e.next</span><br><span class="line">2. 将e.next指向新数组中指定位置newTable[i]</span><br><span class="line">3. newTable[i] = e</span><br><span class="line">4. e = next</span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">现在有链表1-&gt;2-&gt;3，要将它复制到新数组的newTable[i]位置</span><br><span class="line">1. Node e = 1, next = e.next;</span><br><span class="line">2. e.next = newTable[i];</span><br><span class="line">3. newTable[i] = e;</span><br><span class="line">4. e = next, next = e.next;</span><br><span class="line">执行完后会得到这样的结果：</span><br><span class="line">newTable[i]=3-&gt;2-&gt;1</span><br></pre></td></tr></table></figure>

<p>死锁会在这种情况产生：两个线程同时往HashMap里放Entry，同时HashMap正好需要扩容，如果一个线程已经完成了transfer过程，而另一个线程不知道，并且又要进行transfer的时候，死锁就会形成。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">现在Thread1已将完成了transfer，newTable[i]=3-&gt;2-&gt;1</span><br><span class="line">在Thread2中:</span><br><span class="line">Node e = 1, next = e.next;</span><br><span class="line">e.next = newTable[i]    : 1 -&gt; newTable[i]=3</span><br><span class="line">newTable[i] = e         : newTable[i] = 1-&gt;3-&gt;2-&gt;1  //这时候链表换已经形成了</span><br></pre></td></tr></table></figure>

<p>在形成链表换以后再对HashMap进行Get操作时，就会形成死循环。</p>
<p>在Java 8中对这里进行了优化，链表复制到新数组时并不会倒置，不会因为多个线程put导致死循环，但是还有很多弊端，比如数据丢失等，因此多线程情况下还是建议使用ConcurrentHashMap。</p>
<h3 id="HashMap和Hashtable有什么区别"><a href="#HashMap和Hashtable有什么区别" class="headerlink" title="HashMap和Hashtable有什么区别"></a>HashMap和Hashtable有什么区别</h3><p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14423059-b4ca3403f4e917a4.png" loading="lazy"></p>
<p>Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>1. 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。
2. 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。
3. HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。
4. JDK1.8引入红黑树大程度优化了HashMap的性能。
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://theme-next.js.org/2017-03-02-%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%8C%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.svg">
      <meta itemprop="name" content="yangpengbing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦彤blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 亦彤blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017-03-02-%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%8C%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">字面量，常量和变量之间的区别</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-03-02 00:00:00" itemprop="dateCreated datePublished" datetime="2017-03-02T00:00:00+08:00">2017-03-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>经常看到这三者，基本上没有程序员都要和这三者打交道，之前每个都会使用，但是这样的来区别三者之间的关系还是第一次，从定义到实际的例子。这次全面弄清楚，以后就省得定义混淆。</p>
<p>那么我就首先来看个例子，有个大概的了解，再去看看那些生硬的定义。</p>
<p>c&#x2F;c++ code</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a; <span class="comment">// 变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">10</span>; <span class="comment">// b为常量，10为字面量</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;hello world!&quot;</span>; <span class="comment">// str为变量, hello world！为字面量</span></span><br></pre></td></tr></table></figure>
<p>看完这个例子，我相信大家都会有大致的了解，这其中可能稍微有点不太理解的就是<strong>字面量</strong>。</p>
<h1 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h1><blockquote>
<p>在计算机科学中，字面量(literal)是用于表达源代码中一个固定值的表示法(nation)，几乎所有计算机编程语言都具有对基本值的字面量表示，诸如，整数，浮点数以及字符串；而有很多也对布尔类型和字符类型的值也支持字面量表示；还有一些甚至对枚举类型的元素以及像数组，记录和对象等复合类型的值也支持字面量表示。</p>
</blockquote>
<p>有个不太好，但是足以说明问题的解释，那就是对象字面量就是引号引起来的部分，必须是等号右边的部分。虽然这样的解释不太好，但是确实如此，这就是字面量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">10</span>; <span class="comment">// b为常量，10为字面量</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;hello world!&quot;</span>; <span class="comment">// str为变量，hello world!为字面量</span></span><br></pre></td></tr></table></figure>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>有些数据在程序运行中可以变化或者被赋值，这成为变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a; <span class="comment">// a为变量</span></span><br></pre></td></tr></table></figure>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>有些数据可以在程序使用之前预定设定并在整个运行过程中没有变化，称之为常量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">10</span>; <span class="comment">// b为常量，10为字面量</span></span><br></pre></td></tr></table></figure>

<h1 id="常量和变量的区别"><a href="#常量和变量的区别" class="headerlink" title="常量和变量的区别"></a>常量和变量的区别</h1><p>它们内存中的存储方式是一样的，只是常量不允许改变，就像只读一样。</p>
<h1 id="变量，常量和字面量的区别"><a href="#变量，常量和字面量的区别" class="headerlink" title="变量，常量和字面量的区别"></a>变量，常量和字面量的区别</h1><p>字面量是指有字母，数字等构成的字符串和数值。它只能作为右值出现(右值就是等号右边的值，如 int a &#x3D; 123; 这里面a为左值，123为右值)。<br>常量和变量都属于变量，只不过常量是赋值过后不能在改变的变量，而普通的变量是可以在进行赋值操作的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://theme-next.js.org/git/2017-02-22-%E4%BD%BF%E7%94%A8-.gitignore-%E5%BF%BD%E7%95%A5-git-%E4%BB%93%E5%BA%93%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.svg">
      <meta itemprop="name" content="yangpengbing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦彤blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 亦彤blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/git/2017-02-22-%E4%BD%BF%E7%94%A8-.gitignore-%E5%BF%BD%E7%95%A5-git-%E4%BB%93%E5%BA%93%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">使用 .gitignore 忽略 Git 仓库中的文件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-02-22 00:00:00" itemprop="dateCreated datePublished" datetime="2017-02-22T00:00:00+08:00">2017-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/git/" itemprop="url" rel="index"><span itemprop="name">git</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>.gitignore 文件在Git中的使用</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/git/2017-02-22-%E4%BD%BF%E7%94%A8-.gitignore-%E5%BF%BD%E7%95%A5-git-%E4%BB%93%E5%BA%93%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://theme-next.js.org/git/2017-02-16-Git-%E4%BB%A3%E7%A0%81%E5%9B%9E%E6%BB%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.svg">
      <meta itemprop="name" content="yangpengbing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦彤blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 亦彤blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/git/2017-02-16-Git-%E4%BB%A3%E7%A0%81%E5%9B%9E%E6%BB%9A/" class="post-title-link" itemprop="url">Git 代码回滚</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-02-16 00:00:00" itemprop="dateCreated datePublished" datetime="2017-02-16T00:00:00+08:00">2017-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/git/" itemprop="url" rel="index"><span itemprop="name">git</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>回滚代码的正确姿势</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/git/2017-02-16-Git-%E4%BB%A3%E7%A0%81%E5%9B%9E%E6%BB%9A/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://theme-next.js.org/git/2017-02-15-Git%E6%8C%87%E4%BB%A4%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.svg">
      <meta itemprop="name" content="yangpengbing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦彤blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 亦彤blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/git/2017-02-15-Git%E6%8C%87%E4%BB%A4%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">Git指令整理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-02-15 00:00:00" itemprop="dateCreated datePublished" datetime="2017-02-15T00:00:00+08:00">2017-02-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/git/" itemprop="url" rel="index"><span itemprop="name">git</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>不适合阅读的整理的一些个人常用的 Git 指令</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/git/2017-02-15-Git%E6%8C%87%E4%BB%A4%E6%95%B4%E7%90%86/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NexT</span>
</div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <a href="https://theme-next.js.org/">NexT.Gemini</a> 强力驱动
  </div><div class="footer-custom">
Website source code <span class="exturl theme-link" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG8tbmV4dC9oZXhvLW5leHQuZ2l0aHViLmlv">here</span>
</div>


    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhcHB5NTE4" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.8/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/comments.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/motion.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/next-boot.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/pjax.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/third-party/search/local-search.min.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.4.0/mermaid.min.js","integrity":"sha256-3JloMMI/ZQx6ryuhhZTsQJQmGAkXeni6PkshX7UUO2s="}}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/third-party/tags/mermaid.min.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/third-party/math/mathjax.min.js"></script>



</body>
</html>
