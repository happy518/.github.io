<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="5AUIVYTbHIAuz-eQtxSfZbWW5eg9_EVZMSQycIuXrG0">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"theme-next.js.org","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.15.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/config.min.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="亦彤blog">
<meta property="og:url" content="https://theme-next.js.org/page/5/index.html">
<meta property="og:site_name" content="亦彤blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yangpengbing">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://theme-next.js.org/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>亦彤blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-43861RVV8R"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-43861RVV8R","only_pageview":false}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/third-party/analytics/google-analytics.min.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="亦彤blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">亦彤blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-bell fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">58</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yangpengbing"
      src="/images/logo.svg">
  <p class="site-author-name" itemprop="name">yangpengbing</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhcHB5NTE4" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;happy518"><i class="fab fa-github fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>
<div class="cc-license animated" itemprop="sponsor">
  <span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="120" src="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://theme-next.js.org/jdk8/2018-09-25-jdk8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.svg">
      <meta itemprop="name" content="yangpengbing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦彤blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 亦彤blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/jdk8/2018-09-25-jdk8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">jdk8学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-25 00:00:00" itemprop="dateCreated datePublished" datetime="2018-09-25T00:00:00+08:00">2018-09-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jdk8/" itemprop="url" rel="index"><span itemprop="name">jdk8</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>jdk8的新特性，lambda表达式，函数式接口，流的源码分析和使用</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/jdk8/2018-09-25-jdk8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://theme-next.js.org/jvm/2018-04-12%E4%BB%8EJVM%E6%A8%A1%E5%9E%8B%E8%B0%88%E5%8D%81%E7%A7%8D%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.svg">
      <meta itemprop="name" content="yangpengbing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦彤blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 亦彤blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/jvm/2018-04-12%E4%BB%8EJVM%E6%A8%A1%E5%9E%8B%E8%B0%88%E5%8D%81%E7%A7%8D%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">从JVM模型谈十种内存溢出以及解决方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-12 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-12T00:00:00+08:00">2018-04-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><span class="exturl" data-url="aHR0cHM6Ly93d3cudG91dGlhby5jb20vYTY2MzY4NjI3MDE5ODc0MzA5MjUvP3R0X2Zyb209d2VpeGluJnV0bV9jYW1wYWlnbj1jbGllbnRfc2hhcmUmd3hzaGFyZV9jb3VudD0xJnRpbWVzdGFtcD0xNTQ1MjY1NzI5JmFwcD1uZXdzX2FydGljbGUmdXRtX3NvdXJjZT13ZWl4aW4maWlkPTI4NDU2NTA4NDIwJnV0bV9tZWRpdW09dG91dGlhb19pb3MmZ3JvdXBfaWQ9NjYzNjg2MjcwMTk4NzQzMDkyNQ==">https://www.toutiao.com/a6636862701987430925/?tt_from=weixin&amp;utm_campaign=client_share&amp;wxshare_count=1&amp;timestamp=1545265729&amp;app=news_article&amp;utm_source=weixin&amp;iid=28456508420&amp;utm_medium=toutiao_ios&amp;group_id=6636862701987430925<i class="fa fa-external-link-alt"></i></span></p>
<p>对于java程序员来说，在虚拟机自动内存g管理机制的帮助下，不需要自己实现释放内存，不容易出现内存泄露和内存溢出的问题，有虚拟机管理内存这一切看起来很美好，但是一旦出现内存溢出或者内存泄漏的问题，对于不熟悉jvm虚拟机是怎么使用内存的话，那么排查错误将是一项非常艰巨的任务，所以在了解内存溢出之前先要搞清楚jvm的内存模型。</p>
<p>jvm是一个抽象的计算模型，就如同一台真实的机器，他有自己的指令集和执行引擎，可以在运行时操控内存区域，目的是为构建在其之上运行的应用程序提供一个运行环境，jvm可以解读指令代码并于底层进行交互：包括操作系统平台和执行指令并管理资源的硬件体系结构。</p>
<h1 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h1><p>根据java8规范，jvm运行时内存共分为虚拟机栈，堆，元空间，程序计数器，本地方法栈五个部分组成，还有一部分加直接内存，属于操作系统的本地内存，也是可以直接操作的。</p>
<p><img src="http://p99.pstatp.com/large/pgc-image/ea4907261fcb444da561a528c830db9a" loading="lazy"></p>
<ol>
<li>元空间(metaspace)</li>
</ol>
<p>元空间的本质和永久代类似，都是对jvm规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</p>
<ol start="2">
<li>虚拟机栈(jvm stack)</li>
</ol>
<p>每个线程都有一个私有的栈，随着线程的创建而创建，栈里面存着的是一种&quot;栈桢&quot;的东西，每个方法会创建一个栈桢，栈桢中存放了局部变量表(基本数据类型和对象引用)，操作数栈，方法出口等信息。栈的大小可以固定也可以动态扩展。</p>
<ol start="3">
<li>本地方法栈(native method stack)</li>
</ol>
<p>与虚拟机栈类型，区别是虚拟机栈执行java方法，本地方法栈执行native方法，在虚拟机规范中对本地方法栈中方法使用的语言，使用方法和数据结构没有强制规定，因此虚拟机可以自由实现它。</p>
<ol start="4">
<li>程序计数器(program counter register)</li>
</ol>
<p>程序计数器可以看做是当前线程执行字节码的行号提示器。在任何一个确定的时刻，一个处理器(对于多内核来说是一个内核)都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的位置，每条线程都需要一个独立的程序计时器，我们称这类内存区域为&quot;线程私有&quot;内存。</p>
<ol start="5">
<li>堆内存(heap)</li>
</ol>
<p>堆内存是jvm所有线程共享的部分，在虚拟机启动的时候就已经创建，所有的对象和数值都在堆上进行分配，这部分空间可通过GC进行回收。当申请不到空间时会抛出OutOfMemoryError。堆是jvm内存占用最大，管理最复杂的一个区域。其唯一的用途就是存放对象实例；几乎所有对象实例及数组都是在堆上进行分配，jdk8以后，字符串常量池从永久代中剥离出来，存放在其中。</p>
<ol start="6">
<li>直接内存(direct memory)</li>
</ol>
<p>直接内存并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域，在jdk1.4中新加入了NIO(New Input&#x2F;Output)类，引入了一种基于通道(channel)与缓冲区(buffer)的I&#x2F;O方式。它可以使用native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，这样能在一些场景中显著提高性能，因为避免了在java堆和native堆中来回复制数据。</p>
<h1 id="内存溢出的十个场景"><a href="#内存溢出的十个场景" class="headerlink" title="内存溢出的十个场景"></a>内存溢出的十个场景</h1><p>jvm运行时首先需要类加载器(classloader)加载所需要的字节码文件。加载完毕交由执行引擎执行，在执行过程中需要一段空间来存储数据(类比cpu与主存)。这段内存空间的分配和释放过程正是我们需要关心的运行时数据区。内存溢出的情况就是从类加载器加载的时候开始出现的，内存溢出主要分为两大类：OutOfMemoryError和StackOverflowError。以下举出10种内存溢出的情况，并通过实例代码的方式讲解是如何出现内存溢出的。</p>
<ol>
<li>java堆内存溢出</li>
</ol>
<blockquote>
<p>当出现java.lang.OutOfMemoryError：java heap space异常时，就是堆内存溢出了。</p>
</blockquote>
<ul>
<li><p><strong>问题描述</strong></p>
<ul>
<li>设置的jvm堆内存太小，对象所需内存空间太大，创建对象时分配空间不足，就会抛出这个异常。</li>
<li>流量&#x2F;数据峰值，应用程序自身的处理存在一定的限额，比如一定数据量的用户或一定数据量的数据，而当用户数量或数数据量突然激增并超过预期的阈值时，那么就会在峰值停止前正常运行的操作将停止并触发java.lang.OutOfMemoryError：java heap space。</li>
</ul>
</li>
<li><p><strong>示例代码</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ypb.oom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span> HeapOOMErrorTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> java堆内存内存溢出测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangpengbing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 22:50 2018/12/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOMErrorTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1025</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;<span class="type">byte</span>[]&gt; bytes = Lists.newArrayList();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            bytes.add(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span> * m]);</span><br><span class="line">            System.out.println(<span class="string">&quot;count is: &quot;</span> + (++i));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; Short.MAX_VALUE) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上这个示例，如果一次请求只分配5m的内存的话，请求量很少垃圾回收正常就不会出现oom，但是一旦并发上来就会超出最大内存值，就会抛出内存溢出。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Connected to the target VM, address: &#x27;127.0.0.1:58861&#x27;, transport: &#x27;socket&#x27;</span><br><span class="line">count is: 1</span><br><span class="line">count is: 2</span><br><span class="line">count is: 3</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at com.ypb.oom.HeapOOMErrorTest.main(HeapOOMErrorTest.java:22)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>解决方法</strong></li>
</ul>
<p>首先，如果代码没有什么问题的情况下，可以适当的调整下-Xms和-Xmx两个jvm参数，使用压力测试来调整这两个参数达到最优值。</p>
<p>其次，尽量避免大的对象的申请，想文件上传，大批量从数据库中读取，这是需要避免的，尽量分块或者分批次去处理，有助于系统的正常稳定的执行。</p>
<p>最后，尽量提高一次请求的执行速度，垃圾回收越早越好，否则，大量的并发来的时候，再来新的请求就无法分配内存了，就容易造成系统的雪崩。</p>
<ol start="2">
<li>java堆内存泄漏</li>
</ol>
<ul>
<li><strong>问题描述</strong></li>
</ul>
<p>java中内存泄漏是一些对象不再被应用程序使用但垃圾收集无法识别的情况，因此，这些未使用的对象仍然在java堆空间中无限期地存在，不停的堆积最终会触发java.lang.OutOfMemoryError。</p>
<ul>
<li><strong>实例代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ypb.oom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Maps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span> MemoryLeakOOMErrorTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 内存泄漏导致的内存溢出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangpengbing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 17:47 2018/12/23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryLeakOOMErrorTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;Key, String&gt; map = Maps.newHashMap();</span><br><span class="line">        <span class="keyword">while</span> (map.size() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                <span class="type">Key</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Key</span>(i);</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                map.put(key, <span class="string">&quot;number: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Key</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Integer id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Key</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> id.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>分析思路</strong></li>
</ul>
<p>设置的jvm参数：-Xmx256m -Xms256m -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -verbose:gc -Xloggc:E:&#x2F;log.gc -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;E:&#x2F;dump.hprof</p>
<p>控制台输出的结果</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to E:/dump.hprof ...</span><br><span class="line">Heap dump file created [392560701 bytes in 2.937 secs]</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at com.ypb.oom.MemoryLeakOOMErrorTest.main(MemoryLeakOOMErrorTest.java:25)</span><br></pre></td></tr></table></figure>

<p>使用jvisualvm监控得到的结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14423059-2fb37624ef569abb.png" loading="lazy"></p>
<p>从图中可知，大概在17:59:55左右开始，堆的使用比较高，持续到18:00:10左右，堆内存开始下降。18:00:25的时候，堆的使用量几乎为0，然而此时的cpu使用确实100%</p>
<p>分析gc日志得知：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14423059-058af6eaaa2d18e2.png" loading="lazy"></p>
<p>可以看出老年代内存容量使用100%。young gc和full GC都太频繁。</p>
<p>分析dump分析可知：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14423059-d2b4c1b3a9a28c97.png" loading="lazy"></p>
<p>在main native stack thred中占用的内存242M，占比99.77%; 主要是因为HashMap中存在大量的元素导致的。可以看出可能是存在内存泄漏。</p>
<p>当执行上面的代码时，可能会期望它永远运行，不会出现问题，假设单纯的缓存解决方案只将底层映射扩展到10000个元素，而不是所有键都已经存在HashMap中，然而事实上元素将继续被添加，因为key类没有重新它的equals方法。</p>
<p>随着时间推移，随着不断使用的泄漏代码，&quot;缓存&quot;结果最终会消耗大量java堆空间，当泄漏内存填充堆区域中的所有可用内存时，垃圾收集无法清理它，就会触发java.lang.OutOfMemoryError。</p>
<ul>
<li><strong>解决方法</strong></li>
</ul>
<p>相对来说对应的解决方法比较简单，重写equals方法即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ypb.oom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Maps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span> MemoryLeakOOMErrorTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 内存泄漏导致的内存溢出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangpengbing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 17:47 2018/12/23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryLeakOOMErrorTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;Key, String&gt; map = Maps.newHashMap();</span><br><span class="line">        <span class="keyword">while</span> (map.size() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                <span class="type">Key</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Key</span>(i);</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                map.put(key, <span class="string">&quot;number: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Key</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Integer id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Key</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> id.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> Boolean.FALSE;</span><br><span class="line">            <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Key) &#123;</span><br><span class="line">                flag = ((Key) obj).id.equals(<span class="built_in">this</span>.id);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/14423059-fb7b9252b90ee189.png" loading="lazy"></p>
<p>问题解决了</p>
<ol start="3">
<li>垃圾回收超时内存溢出</li>
</ol>
<ul>
<li><strong>问题描述</strong></li>
</ul>
<p>JVM抛出</p>
<p>当应用程序耗尽所有可用内存时，GC开销限制超过了错误，而GC多次未能清除它，这时便会引发java.lang.OutOfMemoryError。当JVM花费大量的时间执行GC，而收效甚微，而一旦整个GC的过程超过限制便会触发错误(默认的jvm配置GC的时间超过98%，回收堆内存低于2%)。</p>
<ul>
<li><strong>实例代码</strong></li>
<li><strong>解决方法</strong></li>
</ul>
<ol start="4">
<li>Metaspace内存溢出</li>
</ol>
<ul>
<li><strong>问题描述</strong></li>
<li><strong>实例代码</strong></li>
<li><strong>分析思路</strong></li>
<li><strong>解决方法</strong></li>
</ul>
<ol start="5">
<li>直接内存内存溢出</li>
</ol>
<ul>
<li><strong>问题描述</strong></li>
<li><strong>实例代码</strong></li>
<li><strong>分析思路</strong></li>
<li><strong>解决方法</strong></li>
</ul>
<ol start="6">
<li>栈内存溢出</li>
</ol>
<ul>
<li><strong>问题描述</strong></li>
<li><strong>实例代码</strong></li>
<li><strong>分析思路</strong></li>
<li><strong>解决方法</strong></li>
</ul>
<ol start="7">
<li>创建本地线程内存溢出</li>
</ol>
<ul>
<li><strong>问题描述</strong></li>
<li><strong>实例代码</strong></li>
<li><strong>分析思路</strong></li>
<li><strong>解决方法</strong></li>
</ul>
<ol start="8">
<li>超出交换区内存溢出</li>
</ol>
<ul>
<li><strong>问题描述</strong></li>
<li><strong>实例代码</strong></li>
<li><strong>分析思路</strong></li>
<li><strong>解决方法</strong></li>
</ul>
<ol start="9">
<li>数组超限内存溢出</li>
</ol>
<ul>
<li><strong>问题描述</strong></li>
<li><strong>实例代码</strong></li>
<li><strong>分析思路</strong></li>
<li><strong>解决方法</strong></li>
</ul>
<ol start="10">
<li>系统杀死进程内存溢出</li>
</ol>
<ul>
<li><strong>问题描述</strong></li>
<li><strong>实例代码</strong></li>
<li><strong>分析思路</strong></li>
<li><strong>解决方法</strong></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://theme-next.js.org/2018-04-11%E7%BE%8E%E5%9B%A2%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8BOOM%EF%BC%8C%E8%BF%9B%E7%A8%8B%E9%87%8C%E7%9A%84%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E8%BF%98%E8%83%BD%E8%BF%90%E8%A1%8C%E5%90%97%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.svg">
      <meta itemprop="name" content="yangpengbing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦彤blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 亦彤blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018-04-11%E7%BE%8E%E5%9B%A2%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8BOOM%EF%BC%8C%E8%BF%9B%E7%A8%8B%E9%87%8C%E7%9A%84%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E8%BF%98%E8%83%BD%E8%BF%90%E8%A1%8C%E5%90%97%EF%BC%9F/" class="post-title-link" itemprop="url">美团面试真题之一个线程OOM，进程里的其他线程还能运行吗？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-11 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-11T00:00:00+08:00">2018-04-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>一个进程有3个线程，如果一个线程抛出OOM，其他两个线程还能运行吗？ </p>
<blockquote>
<p>答案是还能运行</p>
</blockquote>
<p>不瞒大家说，正在面试中，我遇到这一题，我估计也会答错，因为我初看这一题的时候，觉得是在考察JVM的内存结构，我第一反应是OOM常见情况堆内存溢出，也就是下面的这种异常</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError：java heap space</span><br></pre></td></tr></table></figure>

<p>多线程中栈与堆是公有还是私有的</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在多线程环境下，每个线程拥有一个栈和一个程序计数器，栈和程序计数器用来保存线程执行历史和线程执行状态，是线程私有的，堆是由用一个进程内多个线程共享的。</span><br></pre></td></tr></table></figure>

<p>测试代码伪代码如下：</p>
<p>一个线程去构造堆内存溢出，每隔ls申请一次堆内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ypb.oom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span> ThreadOOMTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 测试一个线程出现OOM，同进程下的其他线程还能继续运行吗？</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangpengbing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 22:12 2018/12/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadOOMTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;oom-thread&quot;</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    	    List&lt;<span class="type">byte</span>[]&gt; bytes = Lists.newArrayList();</span><br><span class="line">    	    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    		    show(format(formatter));</span><br><span class="line">    		    </span><br><span class="line">	    	    bytes.add(<span class="keyword">new</span> <span class="title class_">byte</span>[m]);</span><br><span class="line">	    	    </span><br><span class="line">		        sleep();</span><br><span class="line">    	    &#125;</span><br><span class="line">	    &#125;, name).start();</span><br><span class="line"></span><br><span class="line">        name = <span class="string">&quot;not-oom-thread&quot;</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                show(format(formatter));</span><br><span class="line">	            sleep();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, name).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 控制台输出时间和线程名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程休眠1s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">    	    TimeUnit.SECONDS.sleep(<span class="number">1L</span>);</span><br><span class="line">    	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    	    e.printStackTrace();</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 格式化输出的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> formatter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">format</span><span class="params">(DateTimeFormatter formatter)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;data &#123;%s&#125;, thread &#123;%s&#125;&quot;</span>, LocalDateTime.now().format(formatter), Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出的结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14423059-30f285d5b4b1f729.png" loading="lazy"></p>
<p>从日志中可以看出，线程oom-thread线程溢出了，其他线程not-oom-thread线程还在执行中。使用jvisualvm监控下。</p>
<p>设置的jvm参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx32m -Xms32m -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -verbose:gc -XX:+PrintGCDateStamps -Xloggc:E:/gc.log</span><br></pre></td></tr></table></figure>

<p>1<a target="_blank" rel="noopener" href="https://upload-images.jianshu.io/upload_images/14423059-a8f1bf114c7a42d3.png"></a></p>
<p>分析gc日志，可以看出老年代的内存使用率达到99.79%。内存使用率已经满了。出现内存溢出。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14423059-561c9ae2e6106e2d.png" loading="lazy"></p>
<p>上面是jvisualvm监控堆内存变化的结果，注意看图上，抛出OOM的时间在14:56:54左右，重点关注这个时间点左右的曲线变化。发现堆使用的数量突然间急速下滑，这代表这一点，当一个线程抛出OOM异常后，它说占用的内存空间会全部被释放掉，从而不会影响其他线程的运行。</p>
<p>这个例子只是演示了堆内存溢出的情况，如果是栈内存溢出，结论也是一样的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://theme-next.js.org/jvm/2018-04-09-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96java%20gc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.svg">
      <meta itemprop="name" content="yangpengbing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦彤blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 亦彤blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/jvm/2018-04-09-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96java%20gc/" class="post-title-link" itemprop="url">JVM系列之如何优化java gc</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-09 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-09T00:00:00+08:00">2018-04-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>从前面的内容，我们了解到不同的GC算法的执行过程，GC的工作原理，新生代和老年代的概念，JDK7中你需要了解的5种GC类型以及每一种GC对性能的影响。这篇文章基于实际生产环境中的案例，介绍几个GC优化的最佳参数设置。</p>
<h1 id="GC优化是必要的吗"><a href="#GC优化是必要的吗" class="headerlink" title="GC优化是必要的吗?"></a>GC优化是必要的吗?</h1><p>或者更准确的说，GC优化对java基础服务来说是必要的吗？答案是否定的，事实上GC优化对java基础服务来说在有些场合是可以省去的，但前提是这些正在运行的java系统，必须包含以下参数或者行为：</p>
<ul>
<li>内存大小已经通过-Xms和-Xmx参数指定过。</li>
<li>运行在server模式下(使用-server参数)</li>
<li>系统中没有残留超时日志之类的错误日志。</li>
</ul>
<p>换句话说，如果你在运行时没有手动设置内存大小并且打印出了过多的超时日志，那你就需要对系统进行GC优化。</p>
<p>不过你需要时刻谨记一句话：GC tuning is the last task to be done</p>
<p>现在来想一想GC优化的最根本原因，垃圾收集器的工作原理就是清除java创建的对象，垃圾收集器需要清理的对象数量以及要执行的gc数量均取决于已创建的对象数量，因此，为了使你的系统在gc上表现良好，首先需要减少创建对象的数量。</p>
<p>俗话说&quot;冰冻三尺非一日之寒&quot;, 我们在编码时要首先把下面这些小细节做好，否则一些琐碎的不良代码累积起来将gc的工作变得繁重而难于管理：</p>
<ul>
<li>使用StringBuilder或者StringBuffer来代替Stirng</li>
<li>尽量少输出日志</li>
</ul>
<p>尽管如此，仍然会有我们束手无策的情况，xmlh和json解析过程往往占用了最多的内存，即使我们已经尽可能得减少用String，少输出日志，仍然会有大量的临时内存(大约10-100MB)被用来解析xml和json文件，但我们有很难弃用xml和json，在此只需要知道这一过程会占用大量内存即可。</p>
<p>如果在经过几次重复的优化后应用程序的内存占用情况有所改善，那么就可以启动GC优化了</p>
<p>GC优化的两个目的：</p>
<ul>
<li><ol>
<li>进入老年代的对象数量降到最低</li>
</ol>
</li>
<li><ol start="2">
<li>减少Full的执行时间</li>
</ol>
</li>
</ul>
<h2 id="将进入老年代的对象数量降到最低"><a href="#将进入老年代的对象数量降到最低" class="headerlink" title="将进入老年代的对象数量降到最低"></a>将进入老年代的对象数量降到最低</h2><p>除了可以在JDK7以及更高版本中使用G1收集器以外，其他分代GC都是有Oracle JVM提供的，关于分代GC，就是对象在Eden区被创建，随后被转移到Survivor区，在此之后剩余的对象会被转入到老年代，也有一些对象由于占用内存过大，在Eden区被创建后直接被传入老年代，老年代GC相对来说比新生代GC更耗时，因此，减少进入老年代的对象数量可以显著降低Full GC的频率，你可能以为减少进入老年代的对象数量意味着把它们留在新生代，事实正好相反，新生代内存的大小是可以调节的。</p>
<h2 id="降低Full-GC的时间"><a href="#降低Full-GC的时间" class="headerlink" title="降低Full GC的时间"></a>降低Full GC的时间</h2><p>Full GC的执行时间比Minor GC要长的多，因此，如果在Full GC上花费过多的时间(超过1s)，将可能出现超时错误。</p>
<ul>
<li>如果通过减少老年代内存来减少Full GC时间，可能会引起OutOfMemoryError或者导致Full GC的频率升高。</li>
<li>另外，如果通过增加老年代内存来降低Full GC的频率，Full GC的时间可能因此增加。</li>
</ul>
<p>因此，你需要把老年代的大小设置成一个合适的值。</p>
<h1 id="影响GC性能的参数"><a href="#影响GC性能的参数" class="headerlink" title="影响GC性能的参数"></a>影响GC性能的参数</h1><p>不要幻想着&quot;如果有人用他设置的GC参数获取了不错的性能，我们为什么不复制他的参数设置呢？&quot;，因为对于不同的web服务，他们创建对象的大小和生命周期都不相同。</p>
<p>举一个简单的例子：如果一个任务的执行条件是A、B、C、D和E，另外一个完全相同的任务执行条件只有A和B，那么那一个任务执行速度更快呢，作为常识来讲，答案很明显是后者。</p>
<p>Java GC参数的设置也是这个道理，设置好几个参数并不会提升GC的执行速度，反而会是它变得更慢，GC优化的基本原则就是将不同的GC参数应用到两个及以上的服务器上然后比较它们的性能，然后将那些被证明可以提高性能或者减少GC执行时间的参数应用到最终的工作服务器上。</p>
<p>下面这张表展示了内存大小相关且会影响GC性能的GC参数</p>
<table>
<thead>
<tr>
<th align="right">类型</th>
<th align="right">参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="right">堆内存大小</td>
<td align="right">-Xms</td>
<td>启动JVM时堆内存的大小</td>
</tr>
<tr>
<td align="right"></td>
<td align="right">-Xmx</td>
<td>堆内存的最大限制</td>
</tr>
<tr>
<td align="right">新生代空间大小</td>
<td align="right">-XX:NewRatio</td>
<td>新生代和老年代的内存比</td>
</tr>
<tr>
<td align="right"></td>
<td align="right">-XX:NewSize</td>
<td>新生代内存大小</td>
</tr>
<tr>
<td align="right"></td>
<td align="right">-XX:SurvivorRatio</td>
<td>Eden区和Survivor区的内存比</td>
</tr>
</tbody></table>
<p>在进行GC优化时最常用的参数是-Xms，-Xmx和-XX:NewRatio. -Xms和-Xmx参数通常是必须的。所以NewRatio的值将对GC性能产生重要的影响。</p>
<p>有些人可能会问如何设置永久代内存大小，你可以用-XX:PermSize和-XX:MaxPermSize参数来进行设置，但是要记住，只有当出现OutOfMemoryError错误时你才需要去设置永久代内存。</p>
<p>还有一个会影响GC性能的因素是垃圾收集器的类型，下面展示了关于GC类型的可选参数(基于JDK 6.0)</p>
<table>
<thead>
<tr>
<th align="left">GC类型</th>
<th align="left">参数</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Serial GC</td>
<td align="left">-XX:+UseSerialGC</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Parallel GC</td>
<td align="left">-XX:+UseParallel  -XX:ParallelGCThreads&#x3D;value</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Parallel Compacting GC</td>
<td align="left">-XX:+UseParallelOldGC</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">CMS GC</td>
<td align="left">-XX:+UseConcMarkSweepGC  -XX:+UseParNewGC  -XX:+CMSParallelRemarkEnabled  -XX:CMSInitiatingOccupancyFraction&#x3D;value  -XX:+UseCMSInitiatingOccupancyOnly</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">G1</td>
<td align="left">-XX:+UnlockExperimentalVMOptions   -XX:+UseG1GC</td>
<td align="left">在JDK6中这两个参数必须配合使用</td>
</tr>
</tbody></table>
<p>除了G1收集器外，可以通过设置上表中每种类型第一行的参数来切换GC类型，最常见的非侵入式GC就是Serial GC，它针对客户端系统进行了特别的优化。</p>
<p>会影响GC性能的参数还有很多，但是上面的参数会带来最显著的效果，请切记，设置太多的参数并不一定会提升GC的性能。</p>
<h1 id="GC优化的过程"><a href="#GC优化的过程" class="headerlink" title="GC优化的过程"></a>GC优化的过程</h1><p>GC优化过程和大多数常见的提升性能的过程类似，下面是使用的流程：</p>
<ol>
<li>监控GC状态</li>
</ol>
<p>你需要监控GC从而检查系统中运行的GC的各种状态。</p>
<ol start="2">
<li>分析监控结果后决定是否需要优化GC</li>
</ol>
<p>在检查GC状态后，你需要分析监控结果并决定是否需要进行GC优化，如果分析结果显示运行GC的时间只要0.1-0.3秒，那么就不需要把时间浪费在GC优化上，但如果运行GC的时间达到1-3秒，甚至大于10秒，那么GC优化将是很有必要的。</p>
<p>但是，如果你已经分配了大约10G内存给java，并且这些内存无法省下，那么就无法进行GC优化了，在进行GC优化之前，你需要考虑为什么你需要分配这么大的内存空间，如果你分配了1G或者2G大小的内存并且出现了OutOfMemoryError，那你就应该执行堆转储(heap dump)来消除导致异常的原因。</p>
<blockquote>
<p>注意：<br>堆转储(heap dump)是一个用来检查java内存中的对象和数据的内存文件。该文件可以通过通过执行JDK中的jmap命令来创建，在创建文件的过程中，所有java程序都将暂停，因此，不要再系统执行过程中创建该文件.</p>
</blockquote>
<ol start="3">
<li>设置GC类型&#x2F;内存大小</li>
</ol>
<p>如果你决定要进行GC优化，那么你需要选择一个GC类型并且为它设置内存大小，此时如果你有多个服务器，请如上文提到的那样，在每台服务器上设置不同的GC参数并分析它们的区别。</p>
<ol start="4">
<li>分析结果</li>
</ol>
<p>在设置完GC参数后就可以开始收集数据，请在收集至少24小时后再进行结果分析，如果你足够幸运，你可能会找到系统的最佳GC参数，如若不然，你还需要分析输出日志并检查分配的内存，然后需要通过不断GC类型&#x2F;内存大小来找到系统的最佳参数。</p>
<ol start="5">
<li>如果结果令人满意，将参数应用到所有服务器上并结束GC优化</li>
</ol>
<p>如果GC优化的结果令人满意，就可以将参数应用到所有服务器上，并停止GC优化。</p>
<p>下面详细阐述每一步所做的具体工作。</p>
<h1 id="监控GC状态并分析结果"><a href="#监控GC状态并分析结果" class="headerlink" title="监控GC状态并分析结果"></a>监控GC状态并分析结果</h1><p>在运行中的web应用服务器，上查看GC状态的最佳方式就是使用jstat命令。前面已经介绍过jstat命令，</p>
<p>下面的例子展示了某个还没有执行GC优化的jvm的状态(虽然它并不是运行服务器)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcutil 21719 1s</span><br><span class="line">S0    S1    E    O    P    YGC    YGCT    FGC    FGCT GCT</span><br><span class="line">48.66 0.00 48.10 49.70 77.45 3428 172.623 3 59.050 231.673</span><br><span class="line">48.66 0.00 48.10 49.70 77.45 3428 172.623 3 59.050 231.673</span><br></pre></td></tr></table></figure>
<p>我们先看一下YGC(从应用程序启动到采样时发生Young GC的次数)和YGCT(从应用程序启动采样时Young GC所用的时间(单位秒)), 计算YGCT&#x2F;YGC会得出，平均每次新生代的GC耗时50ms, 这是一个很小的数字，通过这个结果可以看出，我们大可不必关注新生代GC对GC性能的影响。</p>
<p>现在来看一下FGC(从应用程序启动到采样时发生Full GC的次数)和FGCT(从应用程序启动到采样时Full GC所用的时间(单位秒))，计算FGCT&#x2F;FGC会得出，平均每次老年代的GC耗时19.86s，有可能是执行了三次Full GC，每次耗时19.68s，也可能是有两次只花了1s，另外花了58s。不管是哪一种情况，GC优化都是很有必要的。</p>
<p>使用jstat命令可以很容易地查看GC状态，但是分析GC的最佳方式是加上 -verbosegc参数来生成日志。在之前的文章中笔者已经解释了如何分析这些日志。HPJmeter是比较常用的的用于分析-verbosegc生成的日志的工具，它简单易用，使用HPJmeter可以很容易地查看GC执行时间以及GC发生频率。</p>
<p>此外，如果GC执行时间满足下列所有条件，就没有必要进行GC优化了：</p>
<ul>
<li>Minor GC执行非常迅速(50ms以内)</li>
<li>Minor GC没有频繁执行(大约10s执行一次)</li>
<li>Full GC执行非常迅速(1s以内)</li>
<li>Full GC没有频繁执行(大约10min执行一次)</li>
</ul>
<p>括号中的数字并不是绝对的，他们也随着服务的状态而变化。有些服务可能要求一次Full GC在0.9s以内，而有些则会放得更宽一些，因此，对于不同的服务。需要按照不同的标准考虑是否需要执行GC优化。</p>
<p>当检测GC状态时，不能只查看Minor GC和Full GC的时间，还必须要关注GC执行的次数，如果新生代空间太小，Minor GC会非常频繁地执行(有时每秒执行一次，甚至更多)，此外。传入老年代的对象数目也会上升，从而导致Full GC的频率升高，因此，在执行jstat命令时，请使用gccapacity参数来查看具体占用了多少空间。</p>
<h1 id="设置GC类型-x2F-内存大小"><a href="#设置GC类型-x2F-内存大小" class="headerlink" title="设置GC类型&#x2F;内存大小"></a>设置GC类型&#x2F;内存大小</h1><h2 id="设置GC类型"><a href="#设置GC类型" class="headerlink" title="设置GC类型"></a>设置GC类型</h2><p>JVM有5种垃圾收集器，但是在JDK7以前的版本中，你只能在Parallel GC，Parallel Compacting GC和CMS GC之中选择。至于具体选择哪个，则没有具体的的原则和规则。</p>
<p>既然这样的话，我们如何来选择GC呢？最好的方法是把三种都用上，但是有一点必须明确CMS GC通常比其他并行(Parallel) GC都要快(这是因为CMS GC是并发的GC)，如果确实如此，那只选择CMS GC优化就可以了，不过CMS GC也总是更快，当出现Concurrent mode failure时，CMS GC就会比并行GC更慢了。</p>
<ul>
<li>Concurrent mode failure</li>
</ul>
<p>现在我们来深入地了解一下concurrent mode failure。</p>
<p>并行GC和CMS GC的最大的区别在于并行GC采用&quot;标记-整理&quot;(Mark-Compact)算法而CMS GC采用&quot;标记-清除&quot;(Mark-Sweep)算法，compact步骤就是通过移动内存来消除内存碎片，从而消除分配内存的内存之间的空白区域。</p>
<p>对于并行GC来说，无论何时执行Full GC。都会进行Compact工作，这消耗了太多时间，不过在执行完Full GC后，下次分配内存将会变得更快(因为执行顺序分配相邻的内存)。</p>
<p>相反，CMS GC没有compact的过程，因此CMS GC运行速度更快，但是也是由于没有整理内存，在进行磁盘清理之前，内存中会存在很多零碎的空白区域，这也导致没有足够的空间分配给大对象，例如，在老年代还有300M可用的空间，但是连一个10M的对象都没有办法被顺序存储在老年代中，在这种情况下，会报出&quot;concurrent mode failure&quot;的warning，然后系统执行compact操作，但是CMS GC在这种情况下执行的compact操作耗时要比并行GC高很多，并且还会导致另外一个问题，关于“concurrent mode failure”的详细说明，可用参考Oracle工程师撰写的 <span class="exturl" data-url="aHR0cHM6Ly9ibG9ncy5vcmFjbGUuY29tL3Bvb25hbS91bmRlcnN0YW5kaW5nLWNtcy1nYy1sb2dz">Understanding CMS GC Logs<i class="fa fa-external-link-alt"></i></span></p>
<p>综上所述，你需要根据你的系统情况为其选择一个最合适的GC类型。</p>
<p>每个系统都有最合适它的GC类型等着你去寻找，如果你有6台服务器，我建议你每两台服务器设置相同的参数，然后加上-verbosegc参数再分析结果。</p>
<h2 id="设置内存大小"><a href="#设置内存大小" class="headerlink" title="设置内存大小"></a>设置内存大小</h2><p>下面展示了内存大小，GC运行次数和GC运行时间之间的关系；</p>
<ul>
<li>大内存空间</li>
</ul>
<ol>
<li>减少GC的次数</li>
<li>提高了GC的运行时间</li>
</ol>
<ul>
<li>小内存空间</li>
</ul>
<ol>
<li>增多了GC的次数</li>
<li>降低了GC的运行时间</li>
</ol>
<p>关于如何设置内存的大小，没有一个标准的答案，如果服务器资源充足并且Full GC能在1s内完成，把内存设置为10GB也是可以的，但是大部分服务器并不处于这种状态中，当内存设置为10G时，Full GC会耗时10-30s，具体的时间自然与对象的大小有关。</p>
<p>既然如此，我们该如何设置内存大小呢，通常我推荐设为500M，这里不是说你要通过-Xms500M和-Xmx500M参数来设置WAS内存，根据GC优化之前的状态，如果Full GC后还剩余300M的空间，那么把内存设置为1G是一个不错的选择(300M(默认程序占用) + 500M(老年代最小空间) + 200M(空闲内存))。这意味着你需要为老年代设置至少500M空间，因此如果你有三个运行服务器，你可以把它们的内存分别设置为1G，1.5G，2G，然后检查结果。</p>
<p>理论上来说，GC执行速度应该遵循1G &gt; 1.5G &gt; 2G，1G内存时GC执行速度更快，然而，理论上的1G内存Full GC消耗1s。2G内存Full GC消耗2s在实际情况中是无法保证的，实际的运行时间还依赖于服务器的性能和对象大小，因此，最好的方法是创建尽可能多的的测量数据并监视它们。</p>
<p>在设置内存空间大小时，你还需要设置一个参数：NewRatio。NewRatio的值是新生代和老年代空间大小的比例，如果-XX:NewRatio&#x3D;1, 则新生代空间:老年代空间&#x3D;1:1，如果堆内存为1G。则新生代:老年代&#x3D;500M:500M，如果NewRation&#x3D;2，这新生代:老年代&#x3D;1:2, 因此，NewRation的值越大，则老年代空间越大，新生代空间越小。</p>
<p>你可能会认为NewRatio为1会是做好的选择，然而事实并非如此，根据经验知道，当NewRatio设置为2或者3时，整个GC的状态表现最好。</p>
<p>完成GC优化最快的方式是什么？答案是比较性能测试结果，为了给每台服务器设置不同的的参数并监控它们，最好查看的是一天或者两天的数据，当通过性能测试来进行GC优化时，你需要在不同的测试时保证它们有相同的负载和运行环境，然而，即使是专业的性能测试人员，想精确的控制负载也很困难，并且需要大量的时间准备，因此，更加方便容易的方法是直接设置参数来运行，然后等待运行结果。</p>
<h1 id="分析GC优化的结果"><a href="#分析GC优化的结果" class="headerlink" title="分析GC优化的结果"></a>分析GC优化的结果</h1><p>在设置了GC参数和-verbosegc参数后，可以使用tail命令确保日志被正确的生成，如果参数设置的不正确或者日志为生成，那你的时间就被白白浪费了，如果日志收集没有时间的话，在收集一天或者两天数据后在检查结果，最简单的方法是把日志从服务器下载到本地，然后用HPJmeter分析数据。</p>
<p>在分析结果时，请关注下列几点(这个优先级是根据自己的经验定的，我认为选取GC参数时应该考虑的最重要的因素是Full GC的运行时间)：</p>
<ul>
<li>单次Full GC的运行时间</li>
<li>单次Minor GC的运行时间</li>
<li>Full GC运行间隔</li>
<li>Minor GC运行间隔</li>
<li>整个Full GC的运行时间</li>
<li>整个Minor GC的运行时间</li>
<li>整个GC的运行时间</li>
<li>Full GC的执行次数</li>
<li>Minor GC的执行次数</li>
</ul>
<p>找到最佳的GC参数是件非常幸运的，然而在大多数时候，我们并不幸运，在进行GC优化时一定要小心谨慎，因为当你试图一次完成所有的优化工作时，可能会出现OutOfMemoryError错误。</p>
<h1 id="优化案例"><a href="#优化案例" class="headerlink" title="优化案例"></a>优化案例</h1><p>到目前为止，我们一直在从理论上介绍GC优化，现在是时候将这些理论付诸实践的时候了，我们通过几个例子来很深入地理解GC优化。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>下面这个例子是Service S的优化，对于最近刚开发的的Service S，执行Full GC需要消耗过多的时间。</p>
<p>现在看一下执行jstat -gcutil的结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S0 S1 E O P YGC YGCT FGC FGCT GCT</span><br><span class="line">12.16 0.00 5.18 63.78 20.32 54 2.047 5 6.946 8.993</span><br></pre></td></tr></table></figure>
<p>左边的Perm区值对于最初的GC优化并不重要，而YGC参数的值更加对于这次优化更为重要。</p>
<p>平均执行一次Minor GC和Full GC消耗的时间如下表所示：</p>
<ul>
<li>Service S的Minor GC和Full GC的平均执行时间</li>
</ul>
<table>
<thead>
<tr>
<th align="left">GC类型</th>
<th align="left">GC执行次数</th>
<th align="left">GC执行时间</th>
<th align="left">平均值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Minor GC</td>
<td align="left">54</td>
<td align="left">2.047s</td>
<td align="left">37ms</td>
</tr>
<tr>
<td align="left">Full GC</td>
<td align="left">5</td>
<td align="left">6.946s</td>
<td align="left">1.389s</td>
</tr>
</tbody></table>
<p>37ms对于Minor GC来说性能还可以，但1.389s对于Full GC来说意味着当Full GC发生时数据库Timeout设置为1s的系统中时，可能会频繁出现超时的情况。</p>
<p>首先，你需要检查开始GC优化之前内存的使用情况，使用jstat -gccapacity命令可以检查内存使用情况，在笔者的服务器上查看的结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NGCMN NGCMX NGC S0C S1C EC OGCMN OGCMX OGC OC PGCMN PGCMX PGC PC YGC FGC</span><br><span class="line">212992.0 212992.0 212992.0 21248.0 21248.0 170496.0 1884160.0 1884160.0 1884160.0 1884160.0 262144.0 262144.0 262144.0 262144.0 54 5</span><br></pre></td></tr></table></figure>

<p>其中的关键值如下:</p>
<ul>
<li>新生代内存使用量: 212,992k</li>
<li>老年代内存使用量: 1,884,160k</li>
</ul>
<p>因此，除了永久代以外，被分配的内存空间加起来有2G, 并且新生代:老年代&#x3D;1:9， 为了得到比使用jstat更细致的结果，还需要加上-verbosegc参数获取日志，并把三台服务器安装如下方式设置(除此外没有使用任何其他参数)</p>
<ul>
<li>NewRatio&#x3D;2</li>
<li>NewRatio&#x3D;3</li>
<li>NewRatio&#x3D;4</li>
</ul>
<p>一天后我得到了系统的GC log，幸运的是，在设置完NewRatio后系统没有发生任何Full GC。</p>
<p>这是为什么呢？ 这是因为大部分对象在创建之后很快被回收了，所有这些对象没有被传入老年代，而是在新生代就被销毁回收了。</p>
<p>在这种情况下，就没有必要去改变其他的参数值了，只要选择一个最合适的NewRatio值即可，那么，如何确定最佳的NewRatio的值呢？为此，我们分析一下每种NewRatio值下Minor GC的平均响应时间。</p>
<p>在每种参数下Minor GC的平均响应时间如下：</p>
<ul>
<li>NewRatio&#x3D;2 45ms</li>
<li>NewRatio&#x3D;3 34ms</li>
<li>NewRatio&#x3D;4 30ms</li>
</ul>
<p>我们可以根据GC时间的长短得出NewRatio&#x3D;4是最佳的参数值(尽管NewRatio&#x3D;4时新生代空间是最小的)。在设置完GC参数之后，服务器没有发生Full GC。</p>
<p>为了说明这个问题，下面是服务执行一段时间后执行jstat -gcutil的结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S0 S1 E O P YGC YGCT FGC FGCT GCT</span><br><span class="line">8.61 0.00 30.67 24.62 22.38 2424 30.219 0 0.000 30.219</span><br></pre></td></tr></table></figure>

<p>你可能会认为是服务器接受的请求比较少才使得GC发生的频率比较低，实际上，虽然Full GC没有执行过，但Minor GC被执行了2424次。</p>
<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>这是一个Service A的例子，我们提供公司内部的应用性能管理系统(APM)发现JVM暂停了相当长的时间(超过了8s)，因此我们进行了GC优化，我们努力寻找JVM暂停的原因，后来发现是因为Full GC执行时间过长，因此我们决定进行GC优化。</p>
<p>在GC优化的开始阶段，我们加上了-verbosegc参数，结果如下图所示：</p>
<ul>
<li>进行GC优化之前STW的时间</li>
</ul>
<p><img src="https://pic.yupoo.com/crowhawk/ebb4b181/a24f4e9b.png" alt="进行GC优化之前STW的时间" loading="lazy"></p>
<p>上图是由HPJmeter生成的图片之一，横坐标表示JVM执行的时间，纵坐标表示每次GC的时间，CMS为绿点，表示Full GC的结果，而Parallel Scavenge为难点，表示Minor GC的结果。</p>
<p>之前我说过CMS GC是最快的GC，但是上面的结果显示在一些时候CMS耗时达到了15s，是什么原因导致了这一结果呢？请记住我之前说的：CMS在执行compact操作时会显著变慢，此外，服务的内存通过-Xms1g和-Xmx4g设置了，而分配的内存只有4G。</p>
<p>因此笔者将GC类型从CMS GC改为了Parallel GC，把内存大小设置为2G，并把NewRatio设为3，在执行jstat -gcutil几小时之后的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S0 S1 E O P YGC YGCT FGC FGCT GCT</span><br><span class="line">0.00 30.48 3.31 26.54 37.01 226 11.131 4 11.758 22.890</span><br></pre></td></tr></table></figure>

<p>Full GC的时间缩短了，变成了每次3s，跟15s比有了显著提升，但是3s依然不够快，为此，笔者创建了下面6种情况：</p>
<ul>
<li>case 1：-XX:UseParallelGC -Xms1536m   -Xmx1536m   -XX:NewRatio&#x3D;2</li>
<li>case 2: -XX:UseParallelGC -Xms1536m   -Xmx1536m   -XX:NewRatio&#x3D;3</li>
<li>case 3: -XX:UseParallelGC -Xms1g      -Xmx1g      -XX:NewRatio&#x3D;3</li>
<li>case 4: -XX:UseParallelOldGC -Xms1536m -Xmx1536m  -XX:NewRatio&#x3D;2</li>
<li>case 5: -XX:UseParallelOldGC -Xms1536m -Xmx1536m  -XX:NewRatio&#x3D;3</li>
<li>case 6: -XX:UseParallelOldGC -Xms1g    -Xmx1g     -XX:NewRatio&#x3D;3</li>
</ul>
<p>上面哪一种情况最快？结果显示，内存空间越小，运行结果最少，下面展示了性能最好的case 6的结果图，它的最慢响应时间只有1.7s，并且响应时间的平均值已经被控制到了1s以内。</p>
<ul>
<li>case 6的持续时间图</li>
</ul>
<p><img src="https://pic.yupoo.com/crowhawk/026cb5ec/dd3bdbb9.png" loading="lazy"></p>
<p>基于上图的结果，按照case 6调整了GC参数，但这却导致了每晚都会发生OutOfMemoryError。很难解释发生异常的具体原因。简单的说，应该是批处理程序导致了内存泄漏，我们正在解决相关的问题。</p>
<p>如果只对GC日志做一些短时间的分析就将相关参数部署到所有服务器行来执行GC优化，这是非常危险的，切记，只有当你同时仔细分析服务的执行情况和GC日志后，才能保证GC优化没有错误地执行。</p>
<p>在上文中，我们通过两个GC优化的例子来说明GC优化是怎样执行的，正如上文中提到的，例子中设置了GC参数可以设置在相同的服务器之上，但前提是它们具有相同的CPU，操作系统，JDK版本并且运行这相同的服务，此外，不要把我使用的参数照搬到你的应用上，它们可能在你的服务器上并不能起到同样良好的效果。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>笔者没有执行heap dump并分析内存的详细情况，而是通过自己的经验进行GC优化，精确的分析内存可以得到更好的优化效果，不过这种分析一般只适用于内存使用量相对固定的场景，如果服务器严重过载并占有了大量的内存，则建议你根据之前的经验进行GC优化。</p>
<p>笔者已经在一些服务器上设置了G1 GC参数并进行了性能测试，但还没有应用到生成环境，G1 GC的速度快于任何其他的GC类型，但是你必须升级到JDK7，此外，暂时还无法保证它的稳定性，没有人知道运行时是否会出现致命的错误，因此，G1 GC暂时还不适合投入应用。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://theme-next.js.org/jvm/2018-04-08-JVM%E7%B3%BB%E5%88%97%E4%B9%8Bjvm%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E8%A7%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.svg">
      <meta itemprop="name" content="yangpengbing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦彤blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 亦彤blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/jvm/2018-04-08-JVM%E7%B3%BB%E5%88%97%E4%B9%8Bjvm%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E8%A7%88/" class="post-title-link" itemprop="url">JVM系列之jvm知识点总览</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-08 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-08T00:00:00+08:00">2018-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><span class="exturl" data-url="aHR0cDovL3d3dy5pdHlvdWtub3cuY29tL2phdmEvMjAxNy8wMy8wMS9qdm0tb3ZlcnZpZXcuaHRtbA==">http://www.ityouknow.com/java/2017/03/01/jvm-overview.html<i class="fa fa-external-link-alt"></i></span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://theme-next.js.org/jvm/2018-04-07-JVM%E7%B3%BB%E5%88%97%E4%B9%8Bjvm%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.svg">
      <meta itemprop="name" content="yangpengbing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦彤blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 亦彤blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/jvm/2018-04-07-JVM%E7%B3%BB%E5%88%97%E4%B9%8Bjvm%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">JVM系列之jvm调优工具</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-07 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-07T00:00:00+08:00">2018-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近在整理一些关于介绍JVM的文章，发现有一些还没有补充全面，其中就包括如何利用工具来监控调优前后的性能变化。工具作为图形化界面来展示更能直观的发现问题，另一方面一些耗费性能的分析(dump文件分析) 一般也不会在生成环境直接分析，往往dump下来的文件大1G左右，人工分析效率低下，因此利用工具来分析JVM相关问题，往往可以达到事半功倍的效果。</p>
<p>jvm监控分析工具一般分为两类，一种是jdk自带的工具，一种是第三方的分析工具，jdk自带工具一般在jdk bin目录下，以exe的形式直接点击就可以使用，其中包含分析工具已经很强大了，几乎涉及了方方面面，但是我们最常用的只有两个，jconsole和jvisualvm，第三方的分析工具比较多，各自的侧重点不同，比较有代表性的：MAT GChisto等。</p>
<p>对于大型java应用程序来说，再精细的测试也难以堵住所有的漏洞，即便我们在测试阶段进行了大量卓有成效的工作，很多问题还是会在生成环境下暴露出来，并且很难在测试环境中进行重现，JVM能够记录下来问题发生时系统的部分运行状态，并将其存储在堆转储(Heap Dump)文件中，从而为我们分析和诊断问题提供了重要的依据，其中visual VM和MAT是dump文件的分析利器。</p>
<h1 id="jdk自带的工具"><a href="#jdk自带的工具" class="headerlink" title="jdk自带的工具"></a>jdk自带的工具</h1><h2 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h2><p>jconsole(java monitoring and management console)是java5开始，在jdk中自带的java监控和管理控制台，用于对jvmn中内存，线程和类等监控，是一个基于jmx(java management extensions)的gui性能监测工具。jconsole使用jvm的扩展机制获取并展示虚拟机中运行的应用程序的性能和资源消耗等信息。</p>
<p>自己在jdk&#x2F;bin目录下点击jconsole.exe即可启动，界面如下：</p>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/jconsole01.jpg" loading="lazy"></p>
<p>在弹出的框中可以选择本机的监控本地的java应用，也可以选择远程的java服务来监控，如果监控远程服务需要在tomcat中启动脚本中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Dcom.sun.management.jmxremote.port=6969</span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=false</span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=false</span><br></pre></td></tr></table></figure>

<p>连接进去之后，就可以看到jconsole概览图和主要的功能：概述，内存，线程，类，vm，mbeans。</p>
<ul>
<li>概述 以图表的方式显示出堆内存使用量，活动线程数，已加载的类，cpu占用率的折线图，可以非常清晰的观察在程序执行过程中的变动情况。</li>
</ul>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/jconsole02.jpg" loading="lazy"></p>
<ul>
<li>内存 主要展示了内存的使用情况，同时可以查看堆和非堆内存的变化值对比，也可以点击执行GC来触发GC的执行</li>
</ul>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/jconsole03.jpg" loading="lazy"></p>
<ul>
<li>线程 主界面展示线程数的活动数和峰值，同时点击左下方线程可以查看线程的详细信息，比如线程的状态是什么，堆栈内容等，同时也可以点击&quot;检测死锁&quot;来检查线程之间是否有死锁的情况。</li>
</ul>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/jconsole04.jpg" loading="lazy"></p>
<ul>
<li>类 主要展示已加载类的相关信息。</li>
<li>VM概要 展示jvm所有信息总览，包括基本信息，线程相关，堆相关，操作系统，vm参数等</li>
<li>mbean 查看mbean的属性和方法等。</li>
</ul>
<h2 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>jvisualvm是一个工具，它提供了一个可视界面，用于查看java虚拟机(jvm virtual machine)上运行的基于java技术的应用程序(java应用程序)的详细信息。visualvm对JDK工具所检索的jvm软件相关数据进行组织，并通过一种使您可以快速查看有多个java应用程序的数据的方式提供该信息，您可以查看本地应用程序已经远程主机上运行的应用程序的相关数据。此外，还可以捕获有关jvm软件实例的数据，并将该数据保存到本地系统，以供后期查看或者与其他用户共享。</p>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/jvisualvm.jpg" loading="lazy"></p>
<p>jvisualvm是jdk自带的最牛逼的调优工具了，也是我们平时使用最多的调优工具，几乎涉及到jvm调优的方法面面，同样是在jdk&#x2F;bin目录下面双击jvisualvm.exe就可以启动起来和jconsole一样可以选择本地和远程，如果需要监控远程同样需要配置相关参数，主界面如下：</p>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/jvisualvm01.jpg" loading="lazy"></p>
<p>visualvm可以根据需要安装不同的插件，每个插件的关注点不同，有点主要监控gc，有的主要监控内存，有点监控线程等。</p>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/jvisualvm02.jpg" loading="lazy"></p>
<p>如何安装：</p>
<blockquote>
<ul>
<li><ol>
<li>从主菜单中选择&quot;工具&quot;--&gt;&quot;插件&quot;</li>
</ol>
</li>
<li><ol start="2">
<li>在&quot;可用插件&quot;标签中，选中该插件的&quot;安装&quot;复选框，点击&quot;安装&quot;</li>
</ol>
</li>
<li><ol start="3">
<li>逐步完成插件安装程序.</li>
</ol>
</li>
</ul>
</blockquote>
<p>我这里以eclipse(pid 22296)为例，双击后直接展开，主界面展示了系统和jvm两大块内容，点击右下方jvm参数和系统属性可以参考详细的参数信息。</p>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/jvisualvm03.jpg" loading="lazy"></p>
<p>因为visualvm插件太多，我这里主要介绍常用三个：监控，线程，visual gc</p>
<p>监控的主页其实也就是，cpu，内存，类，线程图表</p>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/jvisualvm04.jpg" loading="lazy"></p>
<p>线程和jconsole功能没有太大的区别</p>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/jvisualvm05.jpg" loading="lazy"></p>
<p>visual gc是常常使用的一个功能，可以明显的看到年轻代，老年代的内存变化，以及gc频率，gc的时间等。</p>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/jvisualvm06.jpg" loading="lazy"></p>
<p>以上的功能其实jconsole几乎都有，visual vm更全面更直观一些，另外visualvm非常多的其他功能，可以分析dump的内存快照，dump出来的线程快照并且进行分析等，还有其他很多插件大家可以自己去探索。</p>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/jvisualvm07.jpg" loading="lazy"> </p>
<h1 id="第三方调优工具"><a href="#第三方调优工具" class="headerlink" title="第三方调优工具"></a>第三方调优工具</h1><h2 id="MAT"><a href="#MAT" class="headerlink" title="MAT"></a>MAT</h2><h3 id="MAT是什么"><a href="#MAT是什么" class="headerlink" title="MAT是什么"></a>MAT是什么</h3><p>mat(memory analyzer tool)，一个基于eclipse的内存分析工具，是一个快速，功能丰富的java heap分析工具，它可以帮助我们查看内存泄漏和减少内存消耗，使用内存分析工具从众多对象中进行分析，快速的计算出在内存中对象的占用大小，看看是谁阻止了垃圾回收器的回收工作，并可以通过报表直观的查看到可能造成这种结果的对象。</p>
<p>通常内存泄漏分析被认为是一件很有难度的工作，一般有团队中的资深人士进行，不过要介绍的mat被认为是一个傻瓜式的堆转储文件分析工具，你只需要轻轻点击一下鼠标就可以生成一个专业的分析报告，和其他内存泄漏分析工具相比，mat的使用非常容易，基本可以实现一键到位，即使是新手也能够快速上手使用。</p>
<p>MAT以eclipse插件的形式来安装，具体的安装过程就不走这里描述了，可以利用visualvm或者是jmap命令生成堆文件，导入elipse mat中生成分析报告。</p>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/mat01.jpg" loading="lazy"></p>
<p>生成报表的同时，在dump文件的同级目录下生成三份(dump_top_consumers.zip，dump_leak_Suspects.zip，dump_top_components.zip)分析结果的html文件，方便发送给相关同事来查看。</p>
<p>需要关注的是下面的Actions、Reports、Step by step区域：</p>
<ul>
<li>Histogram： 列出内存中的对象，对象的个数已经大小，支持正则表达式查找，也可以计算出该类所有对象的retained size</li>
</ul>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/mat02.jpg" loading="lazy"></p>
<ul>
<li>Dominator Tree：；列出最大的对象以及其依赖存活的Object(大小是以Retained Heap为标准排序的)</li>
</ul>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/mat03.jpg" loading="lazy"></p>
<ul>
<li>Top Customers：通过图形列出最大的object</li>
</ul>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/mat04.jpg" loading="lazy"></p>
<ul>
<li>Duplicate classes：检测由多个类加载器加载的类</li>
<li>Leak Suspects：内存泄漏分析</li>
</ul>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/mat05.jpg" loading="lazy"></p>
<ul>
<li>Top Components：列出大于总堆数的百分之一的报表。</li>
</ul>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/mat06.jpg" loading="lazy"></p>
<ul>
<li>Component Report：分析对象属于同一个包或者被同一个类加载器加载</li>
</ul>
<p>以上只是一个初级的介绍，mat还有更强大的使用，比如对比堆内存，在生产环境中往往为了定位问题，每隔几分钟dump出一个内存快照，随后在对比不同时间的堆内存的变化来发现问题。</p>
<h2 id="GChisto"><a href="#GChisto" class="headerlink" title="GChisto"></a>GChisto</h2><p>GChisto是一款专业分析gc日志的工具，可以通过gc日志来分析：Minor GC，Full GC的时间，频率等等，通过列表，报表，图表等不同的形式来反应gc的情况，虽然界面略显粗糙，但是功能还是不错的。</p>
<p>配置好本地的jdk环境之后，双击GChisto.jar，在弹出的输入框中点击add选择gc.log日志。</p>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/g1.jpg" loading="lazy"></p>
<ul>
<li>GC Pause Stats: 可以查看gc的次数，gc的时间，gc的开销，最大gc时间和最小gc时间等，以及相应的柱状图</li>
</ul>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/g2.jpg" loading="lazy"></p>
<ul>
<li>GC Pause Distribution：查看GC停顿的详细分布，x轴表示垃圾收集停顿时间，y轴表示是停顿次数。</li>
<li>GC Timeline：显示整个时间线上的垃圾收集</li>
</ul>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/g3.jpg" loading="lazy"></p>
<p>不过这款工具已经不再维护，不能识别最新jdk的日志文件。</p>
<h2 id="gcviewer"><a href="#gcviewer" class="headerlink" title="gcviewer"></a>gcviewer</h2><p>GCViewer也是一款分析小工具，用于可视化查看由Sun&#x2F;Orcale，IBM、HP和BEA java虚拟机产生的垃圾收集器的日志，gcviewer个人感觉显示的界面比较乱没有GChisto更专业一些。</p>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/gv.jpg" loading="lazy"></p>
<h2 id="GC-easy"><a href="#GC-easy" class="headerlink" title="GC easy"></a>GC easy</h2><p>这是一个web工具，在线使用非常方便</p>
<p>地址：<span class="exturl" data-url="aHR0cDovL2djZWFzeS5pby8=">gc easy<i class="fa fa-external-link-alt"></i></span></p>
<p>进入官网，将打包好的zip或者gz为后缀的压缩包，过一会就会拿到分析结果。</p>
<p><img src="http://www.itmind.net/assets/images/2017/jvm/gceasy1.png" loading="lazy"><br><img src="http://www.itmind.net/assets/images/2017/jvm/gceasy2.png" loading="lazy"></p>
<p>推荐使用此工具进行gc分析</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://theme-next.js.org/jvm/2018-04-06-JVM%E7%B3%BB%E5%88%97%E4%B9%8Bjava%E6%9C%8D%E5%8A%A1gc%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.svg">
      <meta itemprop="name" content="yangpengbing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦彤blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 亦彤blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/jvm/2018-04-06-JVM%E7%B3%BB%E5%88%97%E4%B9%8Bjava%E6%9C%8D%E5%8A%A1gc%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B/" class="post-title-link" itemprop="url">JVM系列之java服务gc参数调优案例</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-06 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-06T00:00:00+08:00">2018-04-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文介绍一次生产环境的jvm gc相关参数调优的过程，通过参数的调整避免了gc卡顿对java服务成功率的影响。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/jvm/2018-04-06-JVM%E7%B3%BB%E5%88%97%E4%B9%8Bjava%E6%9C%8D%E5%8A%A1gc%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://theme-next.js.org/jvm/2018-04-05-JVM%E7%B3%BB%E5%88%97%E4%B9%8Bjava%20gc%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.svg">
      <meta itemprop="name" content="yangpengbing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦彤blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 亦彤blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/jvm/2018-04-05-JVM%E7%B3%BB%E5%88%97%E4%B9%8Bjava%20gc%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">JVM系列之java gc分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-05 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-05T00:00:00+08:00">2018-04-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>java gc就是jvm记录仪，书画了JVM各个分区的表演</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/jvm/2018-04-05-JVM%E7%B3%BB%E5%88%97%E4%B9%8Bjava%20gc%E5%88%86%E6%9E%90/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://theme-next.js.org/jvm/2018-04-04-JVM%E7%B3%BB%E5%88%97%E4%B9%8Bjvm%E8%B0%83%E4%BC%98%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.svg">
      <meta itemprop="name" content="yangpengbing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦彤blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 亦彤blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/jvm/2018-04-04-JVM%E7%B3%BB%E5%88%97%E4%B9%8Bjvm%E8%B0%83%E4%BC%98%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">JVM系列之jvm调优的常用命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-04 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-04T00:00:00+08:00">2018-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>运用JVM自带的命令可以方便的在生成环境监控和打印堆栈日志信息帮助我们来定位问题！虽然jvm调优成熟的工具已经有很多：jconsole，大名鼎鼎的visualvm，IBM的Memory Analyzer等等。但是在生成环境出现问题的时候，一方面工具的使用会有所限制，另一方面喜欢装X的我们，总喜欢在出现问题的时候在终端输入一些命令来解决。所以的工具几乎都是依赖于jdk的接口和底层的这些命令，研究这些命令的使用也让我们更能了解JVM构成和特征。</p>
<p>SUN JDK监控和故障处理命令有jps、jstat、jmap、jhat、jstack、jinfo等。下面做一一介绍</p>
<h1 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h1><p>JVM Process Status Tool. 显示指定系统内所有的hotspot虚拟机进程</p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></figure>
<h2 id="option参数"><a href="#option参数" class="headerlink" title="option参数"></a>option参数</h2><blockquote>
<ul>
<li>-l: 输出主类全名或jar路径</li>
<li>-q: 只输出LVMID</li>
<li>-m: 输出jvm启动时传递给main()的参数</li>
<li>-v: 输出jvm启动时显示指定的JVM参数</li>
</ul>
</blockquote>
<p>其中[option]、[hostid]参数也可以不写。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jps -l -m</span><br><span class="line">28920 org.apache.catalina.startup.Bootstrap start</span><br><span class="line">11589 org.apache.catalina.startup.Bootstrap start</span><br><span class="line">25816 sun.tools.jps.Jps -l -m</span><br></pre></td></tr></table></figure>

<h1 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h1><p>jstat(JVM Statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载，内存，垃圾收集，JIT编译等运行数据。</p>
<h2 id="命令格式-1"><a href="#命令格式-1" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat [option] LVMID [interval [count]</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><blockquote>
<ul>
<li>option: 操作参数</li>
<li>LVMID: 本地虚拟机进程ID</li>
<li>interval: 连续输出的时间间隔</li>
<li>count: 连续输出的次数</li>
</ul>
</blockquote>
<p><strong>option参数总览</strong></p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Displays...</th>
</tr>
</thead>
<tbody><tr>
<td>class</td>
<td>class loader的行为统计。Statistics on the behavior of the class loader</td>
</tr>
<tr>
<td>compiler</td>
<td>Hotspot JIT编译器行为统计。statistics of the behavior of the Hotspot Just-in-time compiler</td>
</tr>
<tr>
<td>gc</td>
<td>垃圾回收堆的行为统计。statistics of the behavior of the garbage collected heap</td>
</tr>
<tr>
<td>gccapacity</td>
<td>各个垃圾回收代容量(young, old, perm)和他们响应的空间统计。statistics of the capacities of the generations and their corresponding sapces</td>
</tr>
<tr>
<td>gcutil</td>
<td>垃圾回收统计概述。summary of garbage collection statistics</td>
</tr>
<tr>
<td>gccause</td>
<td>垃圾收集统计概述(同-gcutil)，附加最近两次垃圾回收事件的原因。summary of garage collection statistics(same as -gcutil), with the cause of the last and</td>
</tr>
<tr>
<td>gcnew</td>
<td>新生代行为统计。statistics of behavior of the new generation</td>
</tr>
<tr>
<td>gcnewcapacity</td>
<td>新生代与其相应的内存空间统计。 statistics of the sizes of the new generation and its corresponding spaces</td>
</tr>
<tr>
<td>gcold</td>
<td>老年代和永生代行为统计。statistics of the behavior of the old and permanent generations</td>
</tr>
<tr>
<td>gcoldcapacity</td>
<td>老年代行为统计。statistics of the sizes of the old generation</td>
</tr>
<tr>
<td>gcpermcapacity</td>
<td>永生代行为统计。statistics of the sizes of the permanent generation</td>
</tr>
<tr>
<td>printcompilation</td>
<td>Hotspot编译方法统计。Hotspot compilation method statistics</td>
</tr>
</tbody></table>
<p><strong>option参数详解</strong></p>
<p>-class</p>
<p>监视类装载，卸载数量，总空间以及耗费的时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -class 11589</span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     Time   </span><br><span class="line">  7035  14506.3     0     0.0       3.67</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>Loaded：加载class的数量</li>
<li>Bytes: class字节大小</li>
<li>Unloaded: 未加载class的数量</li>
<li>Bytes: 未加载class的字节大小</li>
<li>Time: 加载时间</li>
</ul>
</blockquote>
<p>-compiler</p>
<p>输出JIT编译过的方法数量耗时等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -compiler 1262</span><br><span class="line">Compiled Failed Invalid   Time   FailedType FailedMethod</span><br><span class="line">    2573      1       0    47.60          1 org/apache/catalina/loader/WebappClassLoader findResourceInternal</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>Compiled: 编译数量</li>
<li>Failed: 编译失败的数量</li>
<li>Invalid: 无效数量</li>
<li>Time: 编译耗时</li>
<li>FailedType: 失败类型</li>
<li>FailedMethod: 失败方法的全限定名</li>
</ul>
</blockquote>
<p>-gc</p>
<p>垃圾回收堆的行为统计， <strong>常用命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc 1262</span><br><span class="line">S0C    S1C     S0U     S1U   EC       EU        OC         OU        PC       PU         YGC    YGCT    FGC    FGCT     GCT   </span><br><span class="line">26112.0 24064.0 6562.5  0.0   564224.0 76274.5   434176.0   388518.3  524288.0 42724.7    320    6.417   1      0.398    6.815</span><br></pre></td></tr></table></figure>

<p><strong>C即Capacity总容量，U即Used已使用的容量</strong></p>
<blockquote>
<ul>
<li>S0C: survivor0区的总容量</li>
<li>S1C: survivor1区的总容量</li>
<li>S0U: survivor0区已使用的容量</li>
<li>S1U: survivor1区已使用的容量</li>
<li>EC: Eden区总容量</li>
<li>EU: Eden区已使用的容量</li>
<li>OC: Old区的总容量</li>
<li>OU: Old区已使用的容量</li>
<li>PC: 当前的容量(kb)</li>
<li>PU: perm区的使用(kb)</li>
<li>YGC: 新生代垃圾回收次数</li>
<li>YGCT: 新生代垃圾回收时间</li>
<li>FGC: 老年代垃圾回收次数</li>
<li>FGCT: 老年代垃圾回收时间</li>
<li>GCT: 垃圾回收总消耗时间</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc 1262 2000 20</span><br></pre></td></tr></table></figure>
<p>这个命令意思是每隔2000ms就输出1262的gc情况，一共输出20次</p>
<p>-gccapacity</p>
<p>用gc，不够还会输出java堆各区域使用到的最大，最小空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -gccapacity 1262</span><br><span class="line">NGCMN    NGCMX     NGC    S0C   S1C       EC         OGCMN      OGCMX      OGC        OC       PGCMN    PGCMX     PGC      PC         YGC    FGC </span><br><span class="line">614400.0 614400.0 614400.0 26112.0 24064.0 564224.0   434176.0   434176.0   434176.0   434176.0 524288.0 1048576.0 524288.0 524288.0    320     1 </span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>NGCMN: 新生代占用的最小空间</li>
<li>NGCMX: 新生代占用的最大空间</li>
<li>OGCMN: 老年代占用的最小空间</li>
<li>OGCMX: 老年代占用的最大空间</li>
<li>OGC: 当前老年代的容量(kb)</li>
<li>OC: 当前老年代的空间(kb)</li>
<li>PGCMN: perm占用的最小空间</li>
<li>PGCMX: perm占用的最大空间</li>
</ul>
</blockquote>
<p>-gcutil</p>
<p>用-gc，不过输出的是已使用空间占总空间的百分比</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcutil 28920</span><br><span class="line">S0     S1     E      O      P       YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC                 </span><br><span class="line"> 12.45   0.00  33.85   0.00   4.44      4    0.242     0    0.000    0.242   Allocation Failure   No GC </span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>LGCC: 最近垃圾回收的原因</li>
<li>GCC: 当前垃圾回收的原因</li>
</ul>
</blockquote>
<p>-gcnew</p>
<p>统计新生代的行为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcnew 28920</span><br><span class="line">S0C      S1C      S0U        S1U  TT  MTT  DSS      EC        EU         YGC     YGCT  </span><br><span class="line"> 419392.0 419392.0 52231.8    0.0  6   6    209696.0 3355520.0 1172246.0  4       0.242</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>TT: Tenuring threshold(提升阈值)</li>
<li>MTT: 最大的Tenuring threshold</li>
<li>DSS: survivor区域大小(kb)</li>
</ul>
</blockquote>
<p>-gcnewcapacity</p>
<p>新生代与其相应的内存空间的统计</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcnewcapacity 28920</span><br><span class="line">NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC        YGC   FGC </span><br><span class="line"> 4194304.0  4194304.0  4194304.0 419392.0 419392.0 419392.0 419392.0  3355520.0  3355520.0     4     0</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>NGC: 当前年轻代的容量(kb)</li>
<li>SOCMX: 最大的survivor0空间(kb)</li>
<li>SOC: 当前survivor空间(kb)</li>
<li>ECMX: 最大Eden空间(kb)</li>
<li>EC: 当前Eden空间(kb)</li>
</ul>
</blockquote>
<p>-gcold</p>
<p>统计老年代的行为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstst -gcold 28929</span><br><span class="line">PC       PU        OC           OU       YGC    FGC    FGCT     GCT   </span><br><span class="line">1048576.0  46561.7   6291456.0     0.0      4      0      0.000    0.242</span><br></pre></td></tr></table></figure>

<p>-gcoldcapacity</p>
<p>统计老年代的大小和空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcoldcapacity 28920</span><br><span class="line">OGCMN       OGCMX        OGC         OC         YGC   FGC    FGCT     GCT   </span><br><span class="line">  6291456.0   6291456.0   6291456.0   6291456.0     4     0    0.000    0.242</span><br></pre></td></tr></table></figure>

<p>-gcpermcapacity</p>
<p>永生代行为统计</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcpermcapacity 28920</span><br><span class="line">PGCMN      PGCMX       PGC         PC      YGC   FGC    FGCT     GCT   </span><br><span class="line"> 1048576.0  2097152.0  1048576.0  1048576.0     4     0    0.000    0.242</span><br></pre></td></tr></table></figure>

<p>-printcompilation</p>
<p>Hotspot编译方法统计</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -printcompilation 28920</span><br><span class="line">Compiled  Size  Type Method</span><br><span class="line">    1291      78     1    java/util/ArrayList indexOf</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>Compiled: 被执行的编译任务的数量</li>
<li>Size: 方法字节码的字节数</li>
<li>Type: 编译类型</li>
<li>Method: 编译方法的类名和方法名。类名使用&quot;&#x2F;&quot;代替&quot;.&quot;，作为空间分隔符。方法名是给出类的方法名，格式是一致于Hotspot -XX:+PrintComplation选项</li>
</ul>
</blockquote>
<h1 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h1><p>jmap(JVM Memory Map)命令用于生成Head dump文件，如果不使用这个命令，还可以使用-XX:+HeapDumpOnOutOfMemoryError参数来让虚拟1机出现OOM的时候自动生成dump文件。jmap不仅能生成dump文件，还可以查询finalize执行队列，java堆和永久代的详细信息，如当前使用率，当前使用的是哪种收集器等。</p>
<h2 id="命令格式-2"><a href="#命令格式-2" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] LVMID</span><br></pre></td></tr></table></figure>

<h2 id="option参数-1"><a href="#option参数-1" class="headerlink" title="option参数"></a>option参数</h2><blockquote>
<ul>
<li>dump: 生成堆转储快照</li>
<li>finalizerinfo: 显示F-Queue队列等待Finalize线程执行finalize方法的对象</li>
<li>heap: 显示java堆详细信息</li>
<li>histo: 显示堆中对象的统计信息</li>
<li>permstat: to print permanent generation statistics</li>
<li>F: 当-dump没有响应时，强制生成dump快照</li>
</ul>
</blockquote>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>-dump</p>
<p>常用格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=&lt;filename&gt; pid</span><br></pre></td></tr></table></figure>

<p>dump堆到文件，format指定输出格式，live指明是活着的对象，file指定文件名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=dump.hprof 28920</span><br><span class="line">Dumping heap to /home/xxx/dump.hprof ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure>
<p>dump.hprof这个后缀是为了后续可以直接使用MAT(memory analysis tool)打开。</p>
<p>-finalizerinfo</p>
<p>打印等待回收对象的信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jmap -finalizerinfo 28920</span><br><span class="line">Attaching to process ID 28920, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 24.71-b01</span><br><span class="line">Number of objects pending for finalization: 0</span><br></pre></td></tr></table></figure>
<p>可以看到当前F-Queue队列中并没有等待finalizer线程执行finalize方法的对象</p>
<p>-heap</p>
<p>打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况，可以用此来判断内存目前的使用情况以及垃圾回收情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 28920</span><br><span class="line">Attaching to process ID 28920, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 24.71-b01  </span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s)//GC 方式  </span><br><span class="line"></span><br><span class="line">Heap Configuration: //堆内存初始化配置</span><br><span class="line"> MinHeapFreeRatio = 0 //对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率(default 40)</span><br><span class="line"> MaxHeapFreeRatio = 100 //对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率(default 70)</span><br><span class="line"> MaxHeapSize      = 2082471936 (1986.0MB) //对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小</span><br><span class="line"> NewSize          = 1310720 (1.25MB)//对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小</span><br><span class="line"> MaxNewSize       = 17592186044415 MB//对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小</span><br><span class="line"> OldSize          = 5439488 (5.1875MB)//对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小</span><br><span class="line"> NewRatio         = 2 //对应jvm启动参数-XX:NewRatio=:‘新生代’和‘老生代’的大小比率</span><br><span class="line"> SurvivorRatio    = 8 //对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值 </span><br><span class="line"> PermSize         = 21757952 (20.75MB)  //对应jvm启动参数-XX:PermSize=&lt;value&gt;:设置JVM堆的‘永生代’的初始大小</span><br><span class="line"> MaxPermSize      = 85983232 (82.0MB)//对应jvm启动参数-XX:MaxPermSize=&lt;value&gt;:设置JVM堆的‘永生代’的最大大小</span><br><span class="line"> G1HeapRegionSize = 0 (0.0MB)  </span><br><span class="line"></span><br><span class="line">Heap Usage://堆内存使用情况</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space://Eden区内存分布</span><br><span class="line"> capacity = 33030144 (31.5MB)//Eden区总容量</span><br><span class="line"> used     = 1524040 (1.4534378051757812MB)  //Eden区已使用</span><br><span class="line"> free     = 31506104 (30.04656219482422MB)  //Eden区剩余容量</span><br><span class="line"> 4.614088270399305% used //Eden区使用比率</span><br><span class="line">From Space:  //其中一个Survivor区的内存分布</span><br><span class="line"> capacity = 5242880 (5.0MB)</span><br><span class="line"> used     = 0 (0.0MB)</span><br><span class="line"> free     = 5242880 (5.0MB)</span><br><span class="line"> 0.0% used</span><br><span class="line">To Space:  //另一个Survivor区的内存分布</span><br><span class="line"> capacity = 5242880 (5.0MB)</span><br><span class="line"> used     = 0 (0.0MB)</span><br><span class="line"> free     = 5242880 (5.0MB)</span><br><span class="line"> 0.0% used</span><br><span class="line">PS Old Generation //当前的Old区内存分布</span><br><span class="line"> capacity = 86507520 (82.5MB)</span><br><span class="line"> used     = 0 (0.0MB)</span><br><span class="line"> free     = 86507520 (82.5MB)</span><br><span class="line"> 0.0% used</span><br><span class="line">PS Perm Generation//当前的 “永生代” 内存分布</span><br><span class="line"> capacity = 22020096 (21.0MB)</span><br><span class="line"> used     = 2496528 (2.3808746337890625MB)</span><br><span class="line"> free     = 19523568 (18.619125366210938MB)</span><br><span class="line"> 11.337498256138392% used  </span><br><span class="line"></span><br><span class="line">670 interned Strings occupying 43720 bytes.</span><br></pre></td></tr></table></figure>
<p>可以很清楚的看到java堆中各个区域目前的情况。</p>
<p>-histo</p>
<p>打印堆的对象统计，包括对象数，内存大小等等(因为在dump:live前会进行full gc，如果带上live则只统计活对象，因此不加live的堆大小要大于加live堆的大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo:live 28920 | more</span><br><span class="line">num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:         83613       12012248  &lt;constMethodKlass&gt;</span><br><span class="line">   2:         23868       11450280  [B</span><br><span class="line">   3:         83613       10716064  &lt;methodKlass&gt;</span><br><span class="line">   4:         76287       10412128  [C</span><br><span class="line">   5:          8227        9021176  &lt;constantPoolKlass&gt;</span><br><span class="line">   6:          8227        5830256  &lt;instanceKlassKlass&gt;</span><br><span class="line">   7:          7031        5156480  &lt;constantPoolCacheKlass&gt;</span><br><span class="line">   8:         73627        1767048  java.lang.String</span><br><span class="line">   9:          2260        1348848  &lt;methodDataKlass&gt;</span><br><span class="line">  10:          8856         849296  java.lang.Class</span><br><span class="line">  ....</span><br></pre></td></tr></table></figure>
<p>仅仅打印了前面10行</p>
<p>xml class name是对象类型，说明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">B  byte</span><br><span class="line">C  char</span><br><span class="line">D  double</span><br><span class="line">F  float</span><br><span class="line">I  int</span><br><span class="line">J  long</span><br><span class="line">Z  boolean</span><br><span class="line">[  数组，如[I表示int[]</span><br><span class="line">[L+类名 其他对象</span><br></pre></td></tr></table></figure>

<p>-permstat</p>
<p>打印java堆内存的永久代保存区域的类加载器的智能统计信息。对于每个类加载器而言，它的名称，活跃度，地址，父类加载器，它所加载的类的数量和大小都会被打印。此外，包含的字符串数量和大小也会被打印。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">jmap -permstat 28920</span><br><span class="line">Attaching to process ID 28920, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 24.71-b01</span><br><span class="line">finding class loader instances ..done.</span><br><span class="line">computing per loader stat ..done.</span><br><span class="line">please wait.. computing liveness.liveness analysis may be inaccurate ...</span><br><span class="line"></span><br><span class="line">class_loader            classes bytes   parent_loader           alive?  type  </span><br><span class="line">&lt;bootstrap&gt;             3111    18154296          null          live    &lt;internal&gt;</span><br><span class="line">0x0000000600905cf8      1       1888    0x0000000600087f08      dead    sun/reflect/DelegatingClassLoader@0x00000007800500a0</span><br><span class="line">0x00000006008fcb48      1       1888    0x0000000600087f08      dead    sun/reflect/DelegatingClassLoader@0x00000007800500a0</span><br><span class="line">0x00000006016db798      0       0       0x00000006008d3fc0      dead    java/util/ResourceBundle$RBClassLoader@0x0000000780626ec0</span><br><span class="line">0x00000006008d6810      1       3056      null          dead    sun/reflect/DelegatingClassLoader@0x00000007800500a0</span><br></pre></td></tr></table></figure>

<p> -F 强制模式。如果指定的pid没有响应，请使用jmap -dump或者jmap -histo选项，此模式下，不支持live子选项。 </p>
<h1 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h1><p>jhat(JVM Heap Analysis Tool)命令是和jmap搭配使用的，用来分析jmap生成的dump快照，jhat内置了一个微型的HTTP&#x2F;HTML服务器，生成dump的分析结果后，可以在浏览器中查看，在此需要注意，一般不会直接在服务器上进行分析。因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地服务器或者其它服务器上进行分析。</p>
<h2 id="命令格式-3"><a href="#命令格式-3" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhat [dumpfile]</span><br></pre></td></tr></table></figure>

<h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><blockquote>
<ul>
<li>-stack false|true 关闭对象分配调用栈跟踪(tracking object allocation call statck)。如果分配位置信息在堆转储中不可用，则必须将此标志设置为false。默认值为true</li>
<li>-refs false|true 关闭对象引用跟踪(tracking of reference to objects). 默认值为true，默认情况下，返回的指针是指向其他特定对象的对象，如反向链接或输入引用(references or incoming references),会统计&#x2F;计算堆中的所有对象。</li>
<li>-port port-number设置jhat HTTP server的端口号，默认值7000</li>
<li>-exclude exclude-flie指定对象查询是需要排除的数据成员列表文件(a file that lists data members that should be excluded from the reachable objects query). 例如。如果文件列表列出了java.lang.String.value，那么当从某个特定对象Object o计算可达的对象列表时，引用路径涉及java.lang.String.value的都会被排除。</li>
<li>-baseline exclude-file指定一个基准堆转储(baseline heap dump). 在两个heap dumps中有相同的Object ID的对象会被标记为不是新的(marked as not being new)。其他对象被标记为新的(new). 在比较两个不同的堆转储时很有用。</li>
<li>-debug int设置debug级别，0表示不输出调试信息，值越大则表示输出更详细的debug信息</li>
<li>-version 启动后显示版本信息就退出。</li>
<li>J<flag> 因为jhat命令实际上会启动一个JVM来执行，通过-J可以在启动JVM时传入一些启动参数，例如：-J-Xmx512m，则指定运行jhat的java虚拟机使用的最大堆内存为512m。如果需要使用多个JVM参数，则传入多个-Jxxxx。</flag></li>
</ul>
</blockquote>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jhat -J-Xmx512m dum.hprof</span><br><span class="line">eading from dump.hprof...</span><br><span class="line">Dump file created Fri Mar 11 17:13:42 CST 2016</span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving 271678 objects...</span><br><span class="line">Chasing references, expect 54 dots......................................................</span><br><span class="line">Eliminating duplicate references......................................................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 7000</span><br><span class="line">Server is ready.</span><br></pre></td></tr></table></figure>

<p>中间的J-Xmx512m是在dump快照很大的情况下分配512m内存去启动HTTP服务器，运行完之后就可以在浏览器打开<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo3MDAw6L+b6KGM5b+r54Wn5YiG5p6Q5aCG5b+r54Wn5YiG5p6Q5Li76KaB5Zyo5pyA5ZCO6Z2i55qESGVhcA==">http://localhost:7000进行快照分析堆快照分析主要在最后面的Heap<i class="fa fa-external-link-alt"></i></span> Histogram里，里面根据class列出dump时所有存活对象。</p>
<p><strong>分析同样一个dump快照，MAT需要的额外内存比jhat要小的很多，所以建议使用MAT来进行分析</strong></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>打开浏览器<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo3MDAwLOivpemhtemdouaPkOS+m+S6huWHoOS4quafpeivouWKn+iDveWPr+S+m+S9v+eUqA==">http://localhost:7000,该页面提供了几个查询功能可供使用<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">All classes including platform</span><br><span class="line">Show all members of the rootset</span><br><span class="line">Show instance counts for all classes (including platform)</span><br><span class="line">Show instance counts for all classes (excluding platform)</span><br><span class="line">Show heap histogram</span><br><span class="line">Show finalizer summary</span><br><span class="line">Execute Object Query Language (OQL) query</span><br></pre></td></tr></table></figure>

<p>一般查看堆异常情况主要看这个两个部分，show instance counts for all classes(excluding platform), 平台外的所有对象信息。如下图：</p>
<p><img src="http://ityouknow.com/assets/images/2016/jvm-jhat-excluding-paltform.png" loading="lazy"></p>
<p>show heap histogram以树状图形形式展示堆情况。如下图：</p>
<p><img src="http://ityouknow.com/assets/images/2016/jvm-jhat-heap-histogram.png" loading="lazy"></p>
<p>具体排查时需要结合代码，观察是否大量应该被回收的对象在一直被引用或者是否有占用内存特别大的对象无法被回收。</p>
<p><strong>一般情况下，会down到客户端用工具来分析。</strong></p>
<h1 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h1><p>jstack用于生成java虚拟机当前时刻的线程快照，线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈集合，生成线程快照的主要目的是定位出现长时间卡顿的原因，如线程间死锁，死循环，请求外部资源导致的长时间等待等等，线程出现卡顿的时候提供jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源，如果java程序崩溃生成core文件，jstack工具可以用来获取core文件的java  stack和native stack的信息，从而可以轻松的知道java程序是如果崩溃和在程序何处发生的问题，另外，jstack工具还可以附属到正在运行的java程序中，看到当时的java程序的java stack和native stack的信息，如果现在运行的java程序呈现hung的状态，jstack是非常有用的。</p>
<h2 id="命令格式-4"><a href="#命令格式-4" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [option] LVMID</span><br></pre></td></tr></table></figure>

<h2 id="option参数-2"><a href="#option参数-2" class="headerlink" title="option参数"></a>option参数</h2><blockquote>
<ul>
<li>-F: 当正在输出请求不被响应时，强制输出线程堆栈</li>
<li>-l: 除堆栈外，显示关于锁的附件信息</li>
<li>-m: 如果调用到本地方法的话，可以显示c&#x2F;c++的堆栈</li>
</ul>
</blockquote>
<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">jstack -l 11494 | more</span><br><span class="line">2016-07-28 13:40:04</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (24.71-b01 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;Attach Listener&quot; daemon prio=10 tid=0x00007febb0002000 nid=0x6b6f waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br><span class="line"></span><br><span class="line">&quot;http-bio-8005-exec-2&quot; daemon prio=10 tid=0x00007feb94028000 nid=0x7b8c waiting on condition [0x00007fea8f56e000]</span><br><span class="line">java.lang.Thread.State: WAITING (parking)</span><br><span class="line">	at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">	- parking to wait for  &lt;0x00000000cae09b80&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)</span><br><span class="line">	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2043)</span><br><span class="line">	at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)</span><br><span class="line">	at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104)</span><br><span class="line">	at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1068)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)</span><br><span class="line">	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br><span class="line">Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line">  .....</span><br></pre></td></tr></table></figure>

<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>这里面有一篇文章解释的很好 <span class="exturl" data-url="aHR0cDovL3d3dy5ob2xsaXNjaHVhbmcuY29tL2FyY2hpdmVzLzExMA==">分析打印出来的文件内容<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h1><p>jinfo(JVM Configuration info) 这个命令作用是实时查看和调整虚拟机运行参数，之前的jps -v命令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就需要使用jinfo了。</p>
<h2 id="命令格式-5"><a href="#命令格式-5" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo [oprion] [args] LVMID</span><br></pre></td></tr></table></figure>

<h2 id="oprion参数"><a href="#oprion参数" class="headerlink" title="oprion参数"></a>oprion参数</h2><blockquote>
<ul>
<li>-flag: 输出指定args参数的值</li>
<li>-flags: 不需要args参数，输出所有JVM参数的值</li>
<li>-sysprops: 属性系统属性，等同于System.getProperties();</li>
</ul>
</blockquote>
<h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flag CMSInitiatingOccupancyFraction 11494 </span><br><span class="line">XX:CMSInitiatingOccupancyFraction=80</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://theme-next.js.org/jvm/2018-04-03-JVM%E7%B3%BB%E5%88%97%E4%B9%8Bgc%E7%AE%97%E6%B3%95%E5%92%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.svg">
      <meta itemprop="name" content="yangpengbing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦彤blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 亦彤blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/jvm/2018-04-03-JVM%E7%B3%BB%E5%88%97%E4%B9%8Bgc%E7%AE%97%E6%B3%95%E5%92%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" class="post-title-link" itemprop="url">JVM系列之gc算法和垃圾收集器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-03 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-03T00:00:00+08:00">2018-04-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这篇文章给大家介绍GC都有哪几种算法, 以及JVM都有哪些垃圾收集器, 它们的工作原理。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/jvm/2018-04-03-JVM%E7%B3%BB%E5%88%97%E4%B9%8Bgc%E7%AE%97%E6%B3%95%E5%92%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NexT</span>
</div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <a href="https://theme-next.js.org/">NexT.Gemini</a> 强力驱动
  </div><div class="footer-custom">
Website source code <span class="exturl theme-link" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG8tbmV4dC9oZXhvLW5leHQuZ2l0aHViLmlv">here</span>
</div>


    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhcHB5NTE4" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.8/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/comments.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/motion.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/next-boot.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/pjax.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/third-party/search/local-search.min.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.4.0/mermaid.min.js","integrity":"sha256-3JloMMI/ZQx6ryuhhZTsQJQmGAkXeni6PkshX7UUO2s="}}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/third-party/tags/mermaid.min.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/third-party/math/mathjax.min.js"></script>



</body>
</html>
