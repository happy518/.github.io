<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="5AUIVYTbHIAuz-eQtxSfZbWW5eg9_EVZMSQycIuXrG0">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"theme-next.js.org","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.15.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/config.min.js"></script>

    <meta name="description" content="java线程池ThreadPoolExecutor的工作原理与源码解读">
<meta property="og:type" content="article">
<meta property="og:title" content="java线程池ThreadPoolExecutor的工作原理与源码解读">
<meta property="og:url" content="https://theme-next.js.org/java/learn-java-002/index.html">
<meta property="og:site_name" content="亦彤blog">
<meta property="og:description" content="java线程池ThreadPoolExecutor的工作原理与源码解读">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://theme-next.js.org/java/learn-java-002/14423059-6fbfbb7273dd48a7.png">
<meta property="og:image" content="https://theme-next.js.org/java/learn-java-002/14423059-22cd81af7f72ef15.png">
<meta property="og:image" content="https://theme-next.js.org/java/learn-java-002/14423059-c8c8b02a0eb9028a.png">
<meta property="og:image" content="https://theme-next.js.org/java/learn-java-002/14423059-330bdc6ab704c2da.png">
<meta property="og:image" content="https://theme-next.js.org/java/learn-java-002/14423059-8face7330471f805.png">
<meta property="og:image" content="https://theme-next.js.org/java/learn-java-002/14423059-8a11d5489dd2a180.png">
<meta property="og:image" content="https://theme-next.js.org/java/learn-java-002/14423059-f29213e056b2f535.png">
<meta property="og:image" content="https://theme-next.js.org/java/learn-java-002/14423059-ce84682cc3c8f7dd.png">
<meta property="article:published_time" content="2017-07-12T16:16:40.000Z">
<meta property="article:modified_time" content="2023-04-06T16:20:09.212Z">
<meta property="article:author" content="yangpengbing">
<meta property="article:tag" content="源码">
<meta property="article:tag" content="线程池">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://theme-next.js.org/java/learn-java-002/14423059-6fbfbb7273dd48a7.png">


<link rel="canonical" href="https://theme-next.js.org/java/learn-java-002/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://theme-next.js.org/java/learn-java-002/","path":"java/learn-java-002/","title":"java线程池ThreadPoolExecutor的工作原理与源码解读"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>java线程池ThreadPoolExecutor的工作原理与源码解读 | 亦彤blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-43861RVV8R"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-43861RVV8R","only_pageview":false}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/third-party/analytics/google-analytics.min.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="亦彤blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">亦彤blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-bell fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">58</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">1.</span> <span class="nav-text">使用线程池的好处</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9B%E5%BB%BA"><span class="nav-number">2.</span> <span class="nav-text">线程池创建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%A5%B1%E5%92%8C%E7%AD%96%E7%95%A5"><span class="nav-number">2.1.</span> <span class="nav-text">线程池饱和策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">2.2.</span> <span class="nav-text">线程池的状态</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">线程池执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%84%E4%BB%B6"><span class="nav-number">3.1.</span> <span class="nav-text">线程池的内部组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Worker%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91"><span class="nav-number">3.2.</span> <span class="nav-text">Worker线程的执行逻辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADworker%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E7%A9%BA%E9%97%B2%EF%BC%8C%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%9D%9E%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.3.</span> <span class="nav-text">如何判断worker线程是否空闲，如何区分核心线程和非核心线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%BB%86%E8%8A%82"><span class="nav-number">3.4.</span> <span class="nav-text">其他细节</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yangpengbing"
      src="/images/logo.svg">
  <p class="site-author-name" itemprop="name">yangpengbing</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhcHB5NTE4" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;happy518"><i class="fab fa-github fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>
<div class="cc-license animated" itemprop="sponsor">
  <span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="120" src="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://theme-next.js.org/java/learn-java-002/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.svg">
      <meta itemprop="name" content="yangpengbing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦彤blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="java线程池ThreadPoolExecutor的工作原理与源码解读 | 亦彤blog">
      <meta itemprop="description" content="java线程池ThreadPoolExecutor的工作原理与源码解读">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java线程池ThreadPoolExecutor的工作原理与源码解读
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-07-13 00:16:40" itemprop="dateCreated datePublished" datetime="2017-07-13T00:16:40+08:00">2017-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" itemprop="url" rel="index"><span itemprop="name">线程池</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">java线程池ThreadPoolExecutor的工作原理与源码解读</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>随着cpu核数越来越多，不可避免的利用多线程技术以充分利用其计算能力，所以多线程技术是服务端开发人员必须掌握的技术。</p>
<p>随着线程的创建和销毁，都涉及到系统的调用，比较消耗系统资源，所以就引入了线程池技术,避免频繁的创建和销毁线程。</p>
<p>在我们的开发中&quot;池&quot;的概念并不罕见，有数据库连接池，线程池，对象池，常量池等等。</p>
<p>在java中有一个Executors工具类，可以为我们创建一个线程池，其本质就是new一个ThreadPoolExecutor对象。线程池几乎也是面试题必考的问题。本文结合源码，说说ThreadPoolExecutor的工作原理。</p>
<h1 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h1><ol>
<li>降低资源消耗</li>
</ol>
<p>可以重复利用以创建的线程，降低线程创建和销毁造成的系统资源消耗。</p>
<ol start="2">
<li>提高响应速度</li>
</ol>
<p>当任务达到时，任务可以不需要等待线程创建完就立即执行。</p>
<ol start="3">
<li>提高线程的可管理性</li>
</ol>
<p>线程是稀缺资源，如果无限的创建，不仅回消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配，调优和监控。</p>
<h1 id="线程池创建"><a href="#线程池创建" class="headerlink" title="线程池创建"></a>线程池创建</h1><p>先看一下ThreadPoolExecutor参数最全的构造方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, </span></span><br><span class="line"><span class="params">                            <span class="type">int</span> maximumPoolSize, </span></span><br><span class="line"><span class="params">                            <span class="type">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, </span></span><br><span class="line"><span class="params">                            ThreadFactory threadFactory, </span></span><br><span class="line"><span class="params">                            RejectedExceptionHandler handler)</span>&#123;</span><br><span class="line">  	</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>corePoolSize： 线程池中的核心线程数，说白了就是，即便是线程池里没有任何任务，也会有corePoolSize个线程在候着等任务。</li>
<li>maximumPoolSize： 最大线程数，不管你提交多少任务，线程池里最多工作线程就是maximumPoolSize。</li>
<li>keepAliveTime： 线程的存活时间。当线程池里的线程数大于corePoolSize时，如果登陆keepAliveTime时长还没有任务执行，则线程退出。</li>
<li>unit： 这个是用来指定keepAliveTime的单位，比如秒：TimeUnit.SECONDS。</li>
<li>workQueue： 一个阻塞队列，提交的任务将会被放入到这个队列里。</li>
<li>threadFactory：线程工厂，用来创建线程，主要是为了给线程命名，默认工厂的线程名：pool-1-thread-3。</li>
<li>handler：拒绝策略，当线程池里线程被耗尽了，且队列也满了的时候会调用。</li>
</ol>
<p>上面就是创建线程池用到的参数的详细解释。</p>
<h2 id="线程池饱和策略"><a href="#线程池饱和策略" class="headerlink" title="线程池饱和策略"></a>线程池饱和策略</h2><p>这里提到了线程池饱和策略，那我们就简单介绍下有哪些饱和策略：</p>
<ul>
<li><strong>AbortPolicy</strong></li>
</ul>
<p>为java线程池默认的阻塞策略，不执行此任务，而且直接抛出一个运行时异常，切记ThreadPoolExecutor.execute需要try catch，否则程序直接退出。</p>
<ul>
<li><strong>DiscardPolicy</strong></li>
</ul>
<p>直接抛弃，任务不执行，空方法。</p>
<ul>
<li><strong>DiscardOldestPolicy</strong></li>
</ul>
<p>从队列里抛弃head的一个任务，并再次execute此task。</p>
<ul>
<li><strong>CallerRunsPolicy</strong></li>
</ul>
<p>在调用execute的线程里面执行此command，会阻塞入口。</p>
<ul>
<li><strong>用户自定义拒绝策略(最常用)</strong></li>
</ul>
<p>实现RejectedExceptionHandler，并自己自定义拒绝策略。</p>
<h2 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h2><p>首先，线程池是一个有状态的对象，状态有以下几种:</p>
<ul>
<li><strong>RUNNING:</strong> 运行中，此时线程池能接受任务，并且会处理队列中的任务。</li>
<li><strong>SHUTDOWN:</strong> 关闭中，此时，线程池不再接受新任务，但是会处理队列中的任务。</li>
<li><strong>STOP:</strong> 停止，此时线程池不接受新任务，不会处理队列中任务，还会中断worker线程。</li>
<li><strong>TIDYING:</strong> 清理中，所有任务都已经终止且线程数等于0，开始调用terminated()。</li>
<li><strong>TERMINATED:</strong> 终止，terminated()执行结束。</li>
</ul>
<p>线程池的状态变化方式如下图所示：</p>
<p>&#x2F;&#x2F; TODO</p>
<h1 id="线程池执行流程"><a href="#线程池执行流程" class="headerlink" title="线程池执行流程"></a>线程池执行流程</h1><p>这里用一个图来说明线程池的执行过程。</p>
<p><img src="/java/learn-java-002/14423059-6fbfbb7273dd48a7.png" loading="lazy"></p>
<p><img src="/java/learn-java-002/14423059-22cd81af7f72ef15.png" loading="lazy"></p>
<ol>
<li>任务被提交到线程池，如果当前运行的线程数小于corePoolSize，则创建新的线程来执行任务。(注意，执行这一步骤需要获取全局锁)。</li>
<li>如果运行的线程数等于或者大于corePoolSize，则将任务添加到BlockingQueue队列中。</li>
<li>如果无法将任务加入到BlockingQueue(队列已满)，则在非corePoolSize中创建新的线程来处理任务。(注意，执行这一步骤需要获取全局锁)。</li>
<li>如果创建新线程使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectExceptionHandler.rejectedExecution()方法。</li>
</ol>
<p>ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁(这是一个严重的可伸缩瓶颈)。在ThreadPoolExecutor完成预热之后(当前运行的线程数大于等于corePoolSize)，几乎所有的execute()方法调用都是执行步骤2，而步骤2是不需要获取全局锁的。</p>
<p><strong>注意:</strong> 在每两个操作之间都要重新判断线程池的状态和线程数(中间有其他操作)，这样才能保证ThreadPoolExecutor的线程安全性。</p>
<h2 id="线程池的内部组件"><a href="#线程池的内部组件" class="headerlink" title="线程池的内部组件"></a>线程池的内部组件</h2><h2 id="Worker线程的执行逻辑"><a href="#Worker线程的执行逻辑" class="headerlink" title="Worker线程的执行逻辑"></a>Worker线程的执行逻辑</h2><p>线程池使用worker线程从队列中取任务执行，worker不断从队列中获取任务然后执行，worker线程的执行代码中还包含一些性能优化措施和容错逻辑，比如，第一任务直接放在worker中而不是放入队列中(所以worker每次都先看firstTask是否非空)，任务代码抛异常导致线程终止后，会重新创建一个线程替代挂掉的这个线程等(将processWorkerExit方法的代码)。根据对ThreadPoolExecutor.runWorker代码的分析，得出worker的执行逻辑如下图所示：</p>
<h2 id="如何判断worker线程是否空闲，如何区分核心线程和非核心线程"><a href="#如何判断worker线程是否空闲，如何区分核心线程和非核心线程" class="headerlink" title="如何判断worker线程是否空闲，如何区分核心线程和非核心线程"></a>如何判断worker线程是否空闲，如何区分核心线程和非核心线程</h2><h2 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h2><p>worker线程执行任务前后分别调用beforeExecute()和afterExecute()。</p>
<p>线程池在关闭之后会调用terminated()。</p>
<p>若要监控线程池状态，getPoolSize()，getActiveCount()，getLargestPoolSize()，getTaskCount，getCompletedTaskCount()。</p>
<p>这里以&quot;1.8.0_171&quot;的源代码为例，看一下具体实现。</p>
<ol>
<li>先看一下线程池的execute方法</li>
</ol>
<p>添加任务到线程池的核心方法execute()的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executes the given task sometime in the future.  The task</span></span><br><span class="line"><span class="comment"> * may execute in a new thread or in an existing pooled thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the task cannot be submitted for execution, either because this</span></span><br><span class="line"><span class="comment"> * executor has been shutdown or because its capacity has been reached,</span></span><br><span class="line"><span class="comment"> * the task is handled by the current &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command the task to execute</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException at discretion of</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;, if the task</span></span><br><span class="line"><span class="comment"> *         cannot be accepted for execution</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> command&#125; is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">     * 翻译如下：</span></span><br><span class="line"><span class="comment">     * 如果运行的线程数小于corePoolSize，则尝试以入参任务作为第一个任务启动一个新的线程。</span></span><br><span class="line"><span class="comment">     * 对addWorker的调用以原子性方式检查runState和workerCount,</span></span><br><span class="line"><span class="comment">     * 通过返回false防止在不应该添加线程时添加线程的错误警报。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     * 翻译如下：</span></span><br><span class="line"><span class="comment">     * 如果上一步没有完成任务提交，状态为运行并且任务可以成功添加到队列，</span></span><br><span class="line"><span class="comment">     * 那么我们仍然需要再次检查，如果状态在任务加入队列后变成非运行(可能是执行到这里线程池shutdown了)</span></span><br><span class="line"><span class="comment">     * 非运行状态下，需要reject； 然后在判断当前线程数是否为0(有可能这个时候线程数变成了0)，</span></span><br><span class="line"><span class="comment">     * 如果是，新增一个线程；</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     * 翻译如下：</span></span><br><span class="line"><span class="comment">     * 如果我们不能对任务添加到队列，那么我们尝试添加一个新的线程，如果失败了，</span></span><br><span class="line"><span class="comment">     * 则是线程池已经shutdown或者线程池已经达到饱和状态了，应该reject这个任务。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">// 工作线程数小于核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 直接启动新线程，true表示会再次检查workerCount是否小于corePoolSize</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果工作线程数大于或等于核心线程数</span></span><br><span class="line">    <span class="comment">// 线程的状态为running并且队列未满</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 再次检查线程的的运行状态，如果不是running直接从队列中移除。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 如果线程池状态为shutdown状态，需要将刚刚放入队列中的任务从队列中移除(因为突然发生的shutdown()调用)</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">// 移除成功,拒绝该非运行的任务。</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 防止了shutdown状态下没有活动线程了，但是队列还有任务没有执行的特殊情况。</span></span><br><span class="line">            <span class="comment">// 添加一个null任务是因为shutdown状态下，线程池不再接受新任务</span></span><br><span class="line">            <span class="comment">// 需要重新在创建一个worker线程(因为检查过的核心线程正好挂掉，如果不创建worker则线程池此时进入静止状态)</span></span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果放入阻塞队列失败，这创建非核心worker线程处理给任务</span></span><br><span class="line">    <span class="comment">// 如果队列满了，workerCount大于等于maximumPoolSize，则创建worker线程失败，则将任务交给饱和策略(handler)处理。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/java/learn-java-002/14423059-c8c8b02a0eb9028a.png" loading="lazy"></p>
<p>①. 判断当前活跃线程数是否小于corePoolSize，如果小于，则调用addWorker创建线程执行任务<br><br>②. 如果不小于corePoolSize，则将任务添加到workQueue队列中。<br><br>③. 如果放入workeQueu失败，则创建线程执行任务，如果创建线程失败(当前线程数不小于maximumPoolSize时)，就会调用reject(内部调用handler)拒绝接受任务。</p>
<ol start="2">
<li>再看下addWorker的方法实现</li>
</ol>
<p>addWorker的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks if a new worker can be added with respect to current</span></span><br><span class="line"><span class="comment"> * pool state and the given bound (either core or maximum). If so,</span></span><br><span class="line"><span class="comment"> * the worker count is adjusted accordingly, and, if possible, a</span></span><br><span class="line"><span class="comment"> * new worker is created and started, running firstTask as its</span></span><br><span class="line"><span class="comment"> * first task. This method returns false if the pool is stopped or</span></span><br><span class="line"><span class="comment"> * eligible to shut down. It also returns false if the thread</span></span><br><span class="line"><span class="comment"> * factory fails to create a thread when asked.  If the thread</span></span><br><span class="line"><span class="comment"> * creation fails, either due to the thread factory returning</span></span><br><span class="line"><span class="comment"> * null, or due to an exception (typically OutOfMemoryError in</span></span><br><span class="line"><span class="comment"> * Thread.start()), we roll back cleanly.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 检查是否可以根据当前线程池状态和给定的边界(核心和最大值)添加新woker</span></span><br><span class="line"><span class="comment"> * 如果是，则worderCount将相应的进行调整，如果可能，将创建比启动一个新的worker</span></span><br><span class="line"><span class="comment"> * 运行firstTask作为其第一个任务，如果线程池被停止或者被shutdown，该方法返回false</span></span><br><span class="line"><span class="comment"> * 如果线程工厂在被请求的时候，创建线程失败，也会返回false</span></span><br><span class="line"><span class="comment"> * 如果创建线程失败，要么是由于线程工厂返回null，要么是由于异常(通常是thread.start()中的OutOfMemoryError)</span></span><br><span class="line"><span class="comment"> * 我们将干净地回滚。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstTask the task the new thread should run first (or</span></span><br><span class="line"><span class="comment"> * null if none). Workers are created with an initial first task</span></span><br><span class="line"><span class="comment"> * (in method execute()) to bypass queuing when there are fewer</span></span><br><span class="line"><span class="comment"> * than corePoolSize threads (in which case we always start one),</span></span><br><span class="line"><span class="comment"> * or when the queue is full (in which case we must bypass queue).</span></span><br><span class="line"><span class="comment"> * Initially idle threads are usually created via</span></span><br><span class="line"><span class="comment"> * prestartCoreThread or to replace other dying workers.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 新线程应该首先运行的任务(如果没有线程，则为null)。当线程数量少于corePoolSize线程时(在方法execute()中)，</span></span><br><span class="line"><span class="comment"> * 或者当队列已满时(在这种情况下，我们必须绕过队列)，将使用一个初始化first task创建worker，</span></span><br><span class="line"><span class="comment"> * 初始空闲线程通常是通过prestartCoreThread创建的或者同来替换其他垂死的worker。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> core if true use corePoolSize as bound, else</span></span><br><span class="line"><span class="comment"> * maximumPoolSize. (A boolean indicator is used here rather than a</span></span><br><span class="line"><span class="comment"> * value to ensure reads of fresh values after checking other pool</span></span><br><span class="line"><span class="comment"> * state).</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 如果为true，使用corePoolSize作为边界，否则使用maximumPoolSize为边界，</span></span><br><span class="line"><span class="comment"> * (这里使用boolean作为指示符，而不是使用value，以确保在检查其他线程池状态后读取新值)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    <span class="comment">// java标签</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">// 死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 获取当前线程状态 (running为-536870912，shutdown为0，stop为536870912，tidying为1073741824，terminated为1610612736)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">// 这个逻辑判断有点绕可以改成</span></span><br><span class="line">        <span class="comment">// rs &gt;= SHUTDOWN &amp;&amp; (rs != SHUTDOWN || firstTask != null || workQueue.isEmpty())</span></span><br><span class="line">        <span class="comment">// 逻辑判断成立可以分为下面几种情况均不接受新任务</span></span><br><span class="line">        <span class="comment">// 1. rs &gt; shutdown;  --&gt;不接受新任务</span></span><br><span class="line">        <span class="comment">// 2. rs &gt;= shutdown &amp;&amp; firstTask != null; --&gt;不接受新任务</span></span><br><span class="line">        <span class="comment">// 3. rs &gt;= shutdown &amp;&amp; workQueue.isEmpty(); --&gt;不接受新任务</span></span><br><span class="line">        <span class="comment">// 逻辑判断不成立</span></span><br><span class="line">        <span class="comment">// 1. rs == shutdown &amp;&amp; firstTask != null; 此时不会接受任务，但是仍然会执行队列中的任务</span></span><br><span class="line">        <span class="comment">// 2. rs == shutdown &amp;&amp; firstTask == null; 会执行addWorker(null, false)</span></span><br><span class="line">        <span class="comment">// 防止了SHUTDOWN状态下没有活动线程了，但是队列里还有任务没有执行这种特殊情况</span></span><br><span class="line">        <span class="comment">// 添加了一个null任务是因为SHUTDOWN状态下，线程池不再接受新任务</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 死循环</span></span><br><span class="line">        <span class="comment">// 如果线程池状态为running并且队列中还有需要执行的任务。</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取线程池中的线程数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">            <span class="comment">// 如果超出容量或者最大线程池容量不再接受新任务</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 原子操作增加工作线程数</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="comment">// 跳出retry</span></span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 如果线程池状态发生变化，重新循环</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行到这里说明工作线程数增加成功。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">// running状态 || shutdown状态下清理队列中的剩余任务。</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 检查线程状态</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                    <span class="comment">// 将新启动的线程添加到线程池中</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="comment">// 更新线程池数量数且不超过最大值</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 启动新添加的线程，这个线程首先执行firstTask，然后不停的从队列中取任务执行</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 执行ThreadPoolExecutor的runWorker方法</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 线程启动失败，这从workers中移除w并递减workerCount</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            <span class="comment">// 递减workerCount会tryTerminate方法</span></span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/java/learn-java-002/14423059-330bdc6ab704c2da.png" loading="lazy"></p>
<p>这块代码是在创建非核心线程时，即core为false。判断当前线程数是否大于等于maximumPoolSize，如果大于等于则返回false，即上边说到③中的创建线程失败的情况。</p>
<p>addWorker方法的下半部分：</p>
<p><img src="/java/learn-java-002/14423059-8face7330471f805.png" loading="lazy"></p>
<p>①. 创建Worker对象，用时也会实例化一个Thread对象。<br><br>②. 启动这个线程</p>
<p>adWorker之后是runWorker，第一次启动会执行初始化传递过来的firstTask；然后会从workerQueue中取任务执行，如果队列为空则等待keepAliceTime这么长时间。</p>
<ol start="3">
<li>再到Woker里面看看其实现</li>
</ol>
<p><img src="/java/learn-java-002/14423059-8a11d5489dd2a180.png" loading="lazy"></p>
<p>可以看到在创建Worker时会调用threadFactory来创建一个线程，上面②中启动一个线程就会触发worker的run方法被线程调用。Worker实现了Runable接口。这里使用了委派设计模式</p>
<ol start="4">
<li>接下来看看runWorker方法的逻辑</li>
</ol>
<p>runWorker源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main worker run loop.  Repeatedly gets tasks from queue and</span></span><br><span class="line"><span class="comment"> * executes them, while coping with a number of issues:</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * main worker循环运行，从队列中反复获取task并执行它们，同时处理许多问题：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. We may start out with an initial task, in which case we</span></span><br><span class="line"><span class="comment"> * don&#x27;t need to get the first one. Otherwise, as long as pool is</span></span><br><span class="line"><span class="comment"> * running, we get tasks from getTask. If it returns null then the</span></span><br><span class="line"><span class="comment"> * worker exits due to changed pool state or configuration</span></span><br><span class="line"><span class="comment"> * parameters.  Other exits result from exception throws in</span></span><br><span class="line"><span class="comment"> * external code, in which case completedAbruptly holds, which</span></span><br><span class="line"><span class="comment"> * usually leads processWorkerExit to replace this thread.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 1. 我们可能从一个初始任务开始，在这种情况下我们不需要获取第一个任务。</span></span><br><span class="line"><span class="comment"> * 否则，只要线程池正在运行，我们就会从getTask获取任务，如果它返回null，</span></span><br><span class="line"><span class="comment"> * 则worker由于线程池状态或配置参数的更改而退出。其他退出是由额外的代码中</span></span><br><span class="line"><span class="comment"> * 异常抛出引起的，在这种情况下，completedAbruptlyholds，通常会导致processWorkerExit替换此线程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. Before running any task, the lock is acquired to prevent</span></span><br><span class="line"><span class="comment"> * other pool interrupts while the task is executing, and then we</span></span><br><span class="line"><span class="comment"> * ensure that unless pool is stopping, this thread does not have</span></span><br><span class="line"><span class="comment"> * its interrupt set.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 2. 在运行任何任务之前，获取锁以防止执行时其线程池中断，然后我们</span></span><br><span class="line"><span class="comment"> * 确保出发线程池停止，否则此线程没有设置设置中断。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. Each task run is preceded by a call to beforeExecute, which</span></span><br><span class="line"><span class="comment"> * might throw an exception, in which case we cause thread to die</span></span><br><span class="line"><span class="comment"> * (breaking loop with completedAbruptly true) without processing</span></span><br><span class="line"><span class="comment"> * the task.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 3. 每个任务运行之前都会调用beforeExecute，可能会抛出异常，</span></span><br><span class="line"><span class="comment"> * 在这种情况下，我们会导致线程死掉(使用completedAbruptly打开循环为true)而不处理任务。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. Assuming beforeExecute completes normally, we run the task,</span></span><br><span class="line"><span class="comment"> * gathering any of its thrown exceptions to send to afterExecute.</span></span><br><span class="line"><span class="comment"> * We separately handle RuntimeException, Error (both of which the</span></span><br><span class="line"><span class="comment"> * specs guarantee that we trap) and arbitrary Throwables.</span></span><br><span class="line"><span class="comment"> * Because we cannot rethrow Throwables within Runnable.run, we</span></span><br><span class="line"><span class="comment"> * wrap them within Errors on the way out (to the thread&#x27;s</span></span><br><span class="line"><span class="comment"> * UncaughtExceptionHandler).  Any thrown exception also</span></span><br><span class="line"><span class="comment"> * conservatively causes thread to die.</span></span><br><span class="line"><span class="comment"> *  翻译如下：</span></span><br><span class="line"><span class="comment"> * 4. 假设beforeExecute正常完成，我们运行任务，收集任何抛出的异常已发送到afterExecute。</span></span><br><span class="line"><span class="comment"> * 我们分别处理RuntimeException和Error(这两种异常规范保证我们的陷阱)和任意Throwables。</span></span><br><span class="line"><span class="comment"> * 因为我们无法在Runnable.run中重新抛出Throwables，所以我们在出路的时候将它包装在</span></span><br><span class="line"><span class="comment"> * Errors中(到了线程的UncaughtExceptionHandler)。任何抛出的异常导致线程死亡。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 5. After task.run completes, we call afterExecute, which may</span></span><br><span class="line"><span class="comment"> * also throw an exception, which will also cause thread to</span></span><br><span class="line"><span class="comment"> * die. According to JLS Sec 14.20, this exception is the one that</span></span><br><span class="line"><span class="comment"> * will be in effect even if task.run throws.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 在task.run完成之后，我们将调用afterExecute，这可能也会抛出异常，</span></span><br><span class="line"><span class="comment"> * 这也会导致线程死掉，根据JLS Sec 14.20这个例外是即使task.run抛出异常也将生效。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The net effect of the exception mechanics is that afterExecute</span></span><br><span class="line"><span class="comment"> * and the thread&#x27;s UncaughtExceptionHandler have as accurate</span></span><br><span class="line"><span class="comment"> * information as we can provide about any problems encountered by</span></span><br><span class="line"><span class="comment"> * user code.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 异常机制的净效果是afterExecute和线程的UncaughtExceptionHandler有关user代码</span></span><br><span class="line"><span class="comment"> * 遇到的任何问题的准确信息。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w the worker</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 允许中断</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果getTask返回null，那么getTask中会将workerCount递减，如果异常了这个递减操作会在processWorkerExit中处理。</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/java/learn-java-002/14423059-f29213e056b2f535.png" loading="lazy"></p>
<p>线程调用runWorker，会while循环调用getTask方法从workerQueue队列里读取任务，然后执行任务。只要getTask方法不返回null，此线程就不会退出。</p>
<ol start="5">
<li>在看看getTask方法实现</li>
</ol>
<p>getTask源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs blocking or timed wait for a task, depending on</span></span><br><span class="line"><span class="comment"> * current configuration settings, or returns null if this worker</span></span><br><span class="line"><span class="comment"> * must exit because of any of:</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 根据当前的配置设置，执行阻塞或定时等待task，如果因为如下的任何一个原因导致worker退出，则返回null。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. There are more than maximumPoolSize workers (due to</span></span><br><span class="line"><span class="comment"> *    a call to setMaximumPoolSize).</span></span><br><span class="line"><span class="comment"> * 2. The pool is stopped.</span></span><br><span class="line"><span class="comment"> * 3. The pool is shutdown and the queue is empty.</span></span><br><span class="line"><span class="comment"> * 4. This worker timed out waiting for a task, and timed-out</span></span><br><span class="line"><span class="comment"> *    workers are subject to termination (that is,</span></span><br><span class="line"><span class="comment"> *    &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut || workerCount &gt; corePoolSize&#125;)</span></span><br><span class="line"><span class="comment"> *    both before and after the timed wait, and if the queue is</span></span><br><span class="line"><span class="comment"> *    non-empty, this worker is not the last thread in the pool.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 1. 超过了maximumPoolSize个workers。(由于调用了setMaximumPoolSize)</span></span><br><span class="line"><span class="comment"> * 2. 线程池停止了</span></span><br><span class="line"><span class="comment"> * 3. 线程池shutdown并且队列为空</span></span><br><span class="line"><span class="comment"> * 4. worker超时等于一个task，超时的workers在超时等待之前和之后都会被终止(即，allowCoreThreadTimeOut || workerCount &gt; corePoolSize)</span></span><br><span class="line"><span class="comment"> * 如果队列不为空，那么这个worker不是这个线程池的最后一个线程。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> task, or null if the worker must exit, in which case</span></span><br><span class="line"><span class="comment"> *         workerCount is decremented</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 返回task，如果worder意外退出，返回null，在这种情况下workerCount被递减。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取线程池状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">// 1. rs &gt; shutdown, rs至少大于stop，这个时候不处理队列中的任务</span></span><br><span class="line">        <span class="comment">// 2. rs = shutdown，这个时候需要处理队列中的任务除非队列为空</span></span><br><span class="line">        <span class="comment">// 这两种情况都会返回null，让runWorker退出while循环，也就是当前线程执行完毕，所以workerCount必须递减</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">// 递减wokerCount的值</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">// 标记从队列中取任务时是否设置超时时间</span></span><br><span class="line">        <span class="comment">// 1. core thread允许被超时，那么超过corePoolSize的线程也必定允许被超时</span></span><br><span class="line">        <span class="comment">// 2. allowCoreThreadTimeOut(默认值就是false) || wc &gt; corePoolSize时，一般都是这种情况。core Thread即时空闲也不会被回收，只要超过corePoolSize的线程才会被回收。</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从addWorker可以看到一般wc是不会大于maximumPoolSize，故wc &gt; maximumPoolSize是false，所以需要关心后面半句的情形</span></span><br><span class="line">        <span class="comment">// 1. timed = false，说明wc小于corePoolSize，说明当前运行的线程数小于核心线程数，队列take();</span></span><br><span class="line">        <span class="comment">// 1. timed = true, 说明当前运行的线程数大于核心核心线程数; timedOut == false，第一次循环。从队列中取出不为空的方法返回，或者poll跑异常了重试。</span></span><br><span class="line">        <span class="comment">// 2. timed = true, timedOut == true, 说明有poll操作有超时的;  wc &gt; 1 true，如果队列中不为空，从队列中取出不为空和方法方法。如果队列为空，方法null。</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">// workerCount递减，方法null任务，接受当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 以指定的超时时间从队列中获取任务。</span></span><br><span class="line">            <span class="comment">// 2. core thread 默认没有超时</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 超时</span></span><br><span class="line">            timedOut = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">// 线程被中断重试</span></span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/java/learn-java-002/14423059-ce84682cc3c8f7dd.png" loading="lazy"></p>
<p>①. 先不管allowCoreThreadTimeOut，这个变量的默认值是false，wc &gt; corePoolSize则是判断当前线程数是否大于corePoolSize。<br><br>②. 如果当前线程数大于corePoolSize，这回调用wokerQueue的poll方法获取任务，超时时间就是keepAliveTime。如果超过keepAliveTime时长，poll返回了null，上边提到的while循环就会退出，线程也就执行完了，如果当前线程数小于corePoolSize，则会调用wokerQueue的take方法阻塞在当前。</p>
<ol start="6">
<li>在看看processWorkerExit是如何工作的</li>
</ol>
<p>processWorkerExit源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs cleanup and bookkeeping for a dying worker. Called</span></span><br><span class="line"><span class="comment"> * only from worker threads. Unless completedAbruptly is set,</span></span><br><span class="line"><span class="comment"> * assumes that workerCount has already been adjusted to account</span></span><br><span class="line"><span class="comment"> * for exit.  This method removes thread from worker set, and</span></span><br><span class="line"><span class="comment"> * possibly terminates the pool or replaces the worker if either</span></span><br><span class="line"><span class="comment"> * it exited due to user task exception or if fewer than</span></span><br><span class="line"><span class="comment"> * corePoolSize workers are running or queue is non-empty but</span></span><br><span class="line"><span class="comment"> * there are no workers.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 为垂死的worker执行清理，仅仅是从worker线程中被调用的，除非设置了completedAbruptly。</span></span><br><span class="line"><span class="comment"> * 否则调整workerCount减去已经退出的账户，这个方法从woker set中移除线程，并且如果由于任务异常退出或者如果正在运行线程数小于corePoolSize</span></span><br><span class="line"><span class="comment"> * 或者队列非空但是没有worker，则可能导致线程池终止或替换worker。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w the worker</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> completedAbruptly if the worker died due to user exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span><span class="params">(Worker w, <span class="type">boolean</span> completedAbruptly)</span> &#123;</span><br><span class="line">    <span class="comment">// 正常的话再runWorker的getTask方法中workerCount已经递减过了。</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 累加的线程completedTasks</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">// 从线程池中移除超时或者出现异常的线程</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试停止线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="comment">// 线程不是异常结束</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="comment">// 线程池最小空闲数，允许core thread超时就是0，否则就是corePoolSize</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="comment">// 如果min == 0但是队列不为空要保证有1个线程来执行队列中的任务</span></span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 线程池还不为空那就不用担心了</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 线程异常退出</span></span><br><span class="line">        <span class="comment">// 2. 线程池为空，但是队列中还有任务没有执行，看addWorker方法对这种情况的处理。</span></span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>看看tryTerminate的源码</li>
</ol>
<p>processWorkerExit方法中会尝试调用tryTerminate来终止线程池，这个方法在任何可能导致线程池终止的动作后执行；比如减少workerCount或者shutdown状态下从队列中移除任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transitions to TERMINATED state if either (SHUTDOWN and pool</span></span><br><span class="line"><span class="comment"> * and queue empty) or (STOP and pool empty).  If otherwise</span></span><br><span class="line"><span class="comment"> * eligible to terminate but workerCount is nonzero, interrupts an</span></span><br><span class="line"><span class="comment"> * idle worker to ensure that shutdown signals propagate. This</span></span><br><span class="line"><span class="comment"> * method must be called following any action that might make</span></span><br><span class="line"><span class="comment"> * termination possible -- reducing worker count or removing tasks</span></span><br><span class="line"><span class="comment"> * from the queue during shutdown. The method is non-private to</span></span><br><span class="line"><span class="comment"> * allow access from ScheduledThreadPoolExecutor.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * shutdown和线程池和队列为空，或者stop和线程池为空转换为terminate状态。</span></span><br><span class="line"><span class="comment"> * 如果否则有资格终止但workerCount非零，则中断空闲worker程序以确保关闭信号传播。</span></span><br><span class="line"><span class="comment"> * 必须在任何可能是线程池终止的操作之后调用此方法，在关闭期间减少worker count或者从队列中移除任务。</span></span><br><span class="line"><span class="comment"> * 该方法是非私有的允许从ScheduledThreadPoolExecutor访问。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryTerminate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 以下状态直接返回：</span></span><br><span class="line">        <span class="comment">// 1. 线程池处于running状态</span></span><br><span class="line">        <span class="comment">// 2. runState &gt;= tidying 线程池已经停止了或者在停止。</span></span><br><span class="line">        <span class="comment">// 3. shutdown状态但是任务队列非空</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 只能是以下情形会继续下面的逻辑，结束线程池。</span></span><br><span class="line">        <span class="comment">// 1. shutdown状态，这时不在接受新任务而且队列也为空了</span></span><br><span class="line">        <span class="comment">// 2. stop状态，当调用了shutdownNow方法</span></span><br><span class="line">        <span class="comment">// workerCount不为0则还不能停止线程池，而且这时线程都处于空闲等待的状态。</span></span><br><span class="line">        <span class="comment">// 需要中断让线程醒过来，醒过来的线程才能继续处理shutdown的信号。</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            <span class="comment">// runWorker方法中w.unlock就是为了可以被中断，getTask方法也处理了中断。</span></span><br><span class="line">            <span class="comment">// ONLY_ONE; 这里只需要中断1个线程去处理shutdown信号就可以了。</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 进入tidying状态</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 子类重载，一些资源清理工作</span></span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// terminate状态</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    <span class="comment">// 继续awaitTermination</span></span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shutdown这个方法将runState设置为shutdown，会终止所有空闲的线程，shutdownNow方法将runState设置为stop。和shutdown方法的区别，这个方法会终止所有的线程。主要区别在于shutdown调用的是interrupttIdleWorkers这个方法，而shutdownNow实际上调用的是Worker类的interruptIfStarted方法：</p>
<p>shutdown源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initiates an orderly shutdown in which previously submitted</span></span><br><span class="line"><span class="comment"> * tasks are executed, but no new tasks will be accepted.</span></span><br><span class="line"><span class="comment"> * Invocation has no additional effect if already shut down.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 开始有顺序的shutdown已经执行过的task，但是不会接受新的task</span></span><br><span class="line"><span class="comment"> * 如果已经shutdown了，则调用没有额外的影响。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method does not wait for previously submitted tasks to</span></span><br><span class="line"><span class="comment"> * complete execution.  Use &#123;<span class="doctag">@link</span> #awaitTermination awaitTermination&#125;</span></span><br><span class="line"><span class="comment"> * to do that.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 此方法不需要等待以前提交的task执行完，使用awaitTermination来做它。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 线程池状态设置为shutdown，如果已经至少是这个状态那么则直接返回</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 注意这里是中断所有的空闲线程：runWorker中等待的线程被中断，进入processWorkerExit</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// tryTerminate方法中会保证队列中剩余的任务也会得到执行。</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shutdownNow源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempts to stop all actively executing tasks, halts the</span></span><br><span class="line"><span class="comment"> * processing of waiting tasks, and returns a list of the tasks</span></span><br><span class="line"><span class="comment"> * that were awaiting execution. These tasks are drained (removed)</span></span><br><span class="line"><span class="comment"> * from the task queue upon return from this method.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 尝试停止所有活跃的正在执行的task，停止等待执行的task，</span></span><br><span class="line"><span class="comment"> * 并返回等待执行的task列表，从方法返回后，这些方法将被删除。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method does not wait for actively executing tasks to</span></span><br><span class="line"><span class="comment"> * terminate.  Use &#123;<span class="doctag">@link</span> #awaitTermination awaitTermination&#125; to</span></span><br><span class="line"><span class="comment"> * do that.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 此方法不需要等待主动执行的task的终止，使用awaitTermination来完成此操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;There are no guarantees beyond best-effort attempts to stop</span></span><br><span class="line"><span class="comment"> * processing actively executing tasks.  This implementation</span></span><br><span class="line"><span class="comment"> * cancels tasks via &#123;<span class="doctag">@link</span> Thread#interrupt&#125;, so any task that</span></span><br><span class="line"><span class="comment"> * fails to respond to interrupts may never terminate.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 除了尽最大努力停止正活跃的在执行的task外，没有其他保证。</span></span><br><span class="line"><span class="comment"> * 这个实现是通过Thread.interrupt取消任务的，因此未能响应的中断的task</span></span><br><span class="line"><span class="comment"> * 可能永远不会终止。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 设置线程池为stop状态，不再接受任务且不再执行队列中的任务</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 中断所有的线程</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 返回队列中还没有执行的任务</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>interruptIdleWorkers的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interrupts threads that might be waiting for tasks (as</span></span><br><span class="line"><span class="comment"> * indicated by not being locked) so they can check for</span></span><br><span class="line"><span class="comment"> * termination or configuration changes. Ignores</span></span><br><span class="line"><span class="comment"> * SecurityExceptions (in which case some threads may remain</span></span><br><span class="line"><span class="comment"> * uninterrupted).</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 中断等待任务的线程(显示未被锁定)，以便检查终止或更改配置，</span></span><br><span class="line"><span class="comment"> * 忽略SecurityExceptions(在这种情况下，一些线程可能保持不间断)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyOne If true, interrupt at most one worker. This is</span></span><br><span class="line"><span class="comment"> * called only from tryTerminate when termination is otherwise</span></span><br><span class="line"><span class="comment"> * enabled but there are still other workers.  In this case, at</span></span><br><span class="line"><span class="comment"> * most one waiting worker is interrupted to propagate shutdown</span></span><br><span class="line"><span class="comment"> * signals in case all threads are currently waiting.</span></span><br><span class="line"><span class="comment"> * Interrupting any arbitrary thread ensures that newly arriving</span></span><br><span class="line"><span class="comment"> * workers since shutdown began will also eventually exit.</span></span><br><span class="line"><span class="comment"> * To guarantee eventual termination, it suffices to always</span></span><br><span class="line"><span class="comment"> * interrupt only one idle worker, but shutdown() interrupts all</span></span><br><span class="line"><span class="comment"> * idle workers so that redundant workers exit promptly, not</span></span><br><span class="line"><span class="comment"> * waiting for a straggler task to finish.</span></span><br><span class="line"><span class="comment"> * 翻译如下：</span></span><br><span class="line"><span class="comment"> * 如果true，最多中断一个worker，只有在启用终止时，才从tryTerminate调用这个，</span></span><br><span class="line"><span class="comment"> * 但是仍然有其他的worker，在这种情况下，在在所有线程当前都在等待的情况下，</span></span><br><span class="line"><span class="comment"> * 最多一个worker被中断以传播shutdown信号，中断任意线程，确保关闭开启后新来的</span></span><br><span class="line"><span class="comment"> * worker最终也会终止，总之，只中断一个空闲的worker就足够了，但是shutdown()中断</span></span><br><span class="line"><span class="comment"> * 所有的空闲worker，这样冗余的workers就会迅速退出，而不是等待一个掉队的任务完成。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">interruptIdleWorkers</span><span class="params">(<span class="type">boolean</span> onlyOne)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">            <span class="comment">// w.tryLock能够获到锁，说明该线程没有在运行，因为runWorker中执行任务会先lock</span></span><br><span class="line">            <span class="comment">// 因此保证了中断的肯定是空闲的线程</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Woker类中的方法interruptIfStarted源代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">interruptIfStarted</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="comment">// 初始化时state为-1</span></span><br><span class="line">    <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="literal">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%BA%90%E7%A0%81/" rel="tag"># 源码</a>
              <a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag"># 线程池</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/java/learn-java-004/" rel="prev" title="Java多线程学习">
                  <i class="fa fa-chevron-left"></i> Java多线程学习
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/java/learn-java-003/" rel="next" title="死磕Java并发-深入分析volatile的实现原理">
                  死磕Java并发-深入分析volatile的实现原理 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NexT</span>
</div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <a href="https://theme-next.js.org/">NexT.Gemini</a> 强力驱动
  </div><div class="footer-custom">
Website source code <span class="exturl theme-link" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG8tbmV4dC9oZXhvLW5leHQuZ2l0aHViLmlv">here</span>
</div>


    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhcHB5NTE4" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.8/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/comments.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/motion.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/next-boot.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/pjax.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/third-party/search/local-search.min.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.4.0/mermaid.min.js","integrity":"sha256-3JloMMI/ZQx6ryuhhZTsQJQmGAkXeni6PkshX7UUO2s="}}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/third-party/tags/mermaid.min.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/third-party/math/mathjax.min.js"></script>



</body>
</html>
