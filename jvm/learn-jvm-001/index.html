<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="5AUIVYTbHIAuz-eQtxSfZbWW5eg9_EVZMSQycIuXrG0">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"theme-next.js.org","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.15.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/config.min.js"></script>

    <meta name="description" content="类加载机制的奥妙">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM系列之java类加载机制">
<meta property="og:url" content="https://theme-next.js.org/jvm/learn-jvm-001/index.html">
<meta property="og:site_name" content="亦彤blog">
<meta property="og:description" content="类加载机制的奥妙">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://theme-next.js.org/jvm/learn-jvm-001/jvm-1.png">
<meta property="og:image" content="https://theme-next.js.org/jvm/learn-jvm-001/class.png">
<meta property="og:image" content="https://theme-next.js.org/jvm/learn-jvm-001/%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.jpg">
<meta property="og:image" content="https://theme-next.js.org/jvm/learn-jvm-001/%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.jpg">
<meta property="og:image" content="https://theme-next.js.org/jvm/learn-jvm-001/calssloader.png">
<meta property="og:image" content="https://theme-next.js.org/jvm/learn-jvm-001/14423059-54897a5d741e7f0e.png">
<meta property="article:published_time" content="2018-04-01T07:51:43.000Z">
<meta property="article:modified_time" content="2023-04-07T09:35:35.708Z">
<meta property="article:author" content="yangpengbing">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://theme-next.js.org/jvm/learn-jvm-001/jvm-1.png">


<link rel="canonical" href="https://theme-next.js.org/jvm/learn-jvm-001/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://theme-next.js.org/jvm/learn-jvm-001/","path":"jvm/learn-jvm-001/","title":"JVM系列之java类加载机制"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JVM系列之java类加载机制 | 亦彤blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-43861RVV8R"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-43861RVV8R","only_pageview":false}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/third-party/analytics/google-analytics.min.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="亦彤blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">亦彤blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-bell fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">60</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.</span> <span class="nav-text">什么是类的加载</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.</span> <span class="nav-text">类的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD"><span class="nav-number">2.1.</span> <span class="nav-text">加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5"><span class="nav-number">2.2.</span> <span class="nav-text">连接</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E7%BC%93%E5%AD%98"><span class="nav-number">3.</span> <span class="nav-text">类缓存</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8"><span class="nav-number">4.</span> <span class="nav-text">对象在内存中存储</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%8D%A0%E7%94%A8%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F"><span class="nav-number">4.1.</span> <span class="nav-text">计算对象在内存中占用的空间大小</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.</span> <span class="nav-text">访问对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">6.</span> <span class="nav-text">类加载器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="nav-number">7.</span> <span class="nav-text">类的加载</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-number">8.</span> <span class="nav-text">双亲委派模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">9.</span> <span class="nav-text">自定义类加载器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3%E5%8F%A6%E5%A4%96%E4%B8%A4%E4%B8%AA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">10.</span> <span class="nav-text">了解另外两个类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">10.1.</span> <span class="nav-text">线程上下文类加载器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">11.</span> <span class="nav-text">Tomcat服务器的类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#tomcat%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">11.1.</span> <span class="nav-text">tomcat不能使用系统默认的类加载器</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yangpengbing"
      src="/images/logo.svg">
  <p class="site-author-name" itemprop="name">yangpengbing</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhcHB5NTE4" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;happy518"><i class="fab fa-github fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>
<div class="cc-license animated" itemprop="sponsor">
  <span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="120" src="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://theme-next.js.org/jvm/learn-jvm-001/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.svg">
      <meta itemprop="name" content="yangpengbing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦彤blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="JVM系列之java类加载机制 | 亦彤blog">
      <meta itemprop="description" content="类加载机制的奥妙">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM系列之java类加载机制
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-01 15:51:43" itemprop="dateCreated datePublished" datetime="2018-04-01T15:51:43+08:00">2018-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">类加载机制的奥妙</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="什么是类的加载"><a href="#什么是类的加载" class="headerlink" title="什么是类的加载"></a>什么是类的加载</h1><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放到运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向java程序员提供了访问方法区内的数据结构的接口。</p>
<p><img src="/jvm/learn-jvm-001/jvm-1.png" alt="img" loading="lazy"></p>
<p>类加载器并不需要等到某个类被&quot;首次主动使用&quot;时在加载它，JVM规范允许类加载在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或者存在错误，类加载器必须在程序首次主动使用该类时才会报告错误(LinkageError错误)，如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p>
<p><strong>加载.class文件的方式</strong></p>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络下载.class文件</li>
<li>从zip,jar等归档文件中加载.class文件</li>
<li>从专有数据库中提取.class文件</li>
<li>将java源文件动态编译为.class文件</li>
</ul>
<h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p><img src="/jvm/learn-jvm-001/class.png" alt="img" loading="lazy"></p>
<p>其中类加载的过程包括了加载，验证，准备，解析，初始化五个阶段，在这五个阶段中，加载，验证，准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持java语言的运行时绑定(也称之为动态绑定)，另外注意这里的几个阶段是按顺序开始，而不是按照顺序进行或者完成，因为这些阶段通常都是相互交叉地混合进行的，通常在一个阶段执行过程中调用或者激活另一个阶段。</p>
<blockquote>
<p>这里简要的说下Java中的绑定: 绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来，对于java来说，绑定分为静态绑定和动态绑定：</p>
<ul>
<li>静态绑定：即前期绑定。在程序执行前方法已经被绑定，此时有编译器或者其它连接程序实现，针对java，简单的可以理解为程序编译期的绑定，在java当中方法只有final，static，private和构造方法是前期绑定的。</li>
<li>动态绑定：即晚期绑定，也叫做运行时绑定，在运行时根据具体对象的类型进行绑定，在java中，几乎所有的方法都是后期绑定的。</li>
</ul>
</blockquote>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>查询并加装类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p>
<ul>
<li>通过一个类的全限定名来获取其定义的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构。</li>
<li>在java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区这是数据的访问入口。</li>
</ul>
<p>相对于类加载的其他阶段而言，加载阶段(准备的说，是加载阶段获取类的二进制字节流的动作)是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在java堆中也创建一个java.lang.Class类的对象，这样便可以通过这个对象访问方法区中的这些数据。</p>
<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p><strong>验证：确保被加载的类的正确性</strong></p>
<p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的验证动作：</p>
<ul>
<li>文件格式验证：验证字节流是否符合Class文件格式的规范; 例如：是否以0xCAFEBABE开头，主次版本号是否在当前虚拟机的处理范围之内，常量池中的常量是否有不被支持的类型。</li>
<li>元数据验证：对字节码描述的信息进行语义分析(注意：对比javac编译阶段的语义分析)，以保证其描述的信息符合java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。</li>
<li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。</li>
<li>符号引用验证：确保解析动作能够正确执行。</li>
</ul>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类型经过反复验证，可以考虑采用 -Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<p><strong>准备：为类的静态变量分配内存，并将其初始化为默认值</strong></p>
<p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配，对于该阶段有以下几点需要注意：</p>
<ul>
<li>这时候进行内存分配的仅包括类变量(static)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在java堆中。</li>
<li>这里所设置的初始值通常情况下是数据类型的默认的零值(如0， 0L，null，false等), 而不是被在java代码中被显式地赋予的值。</li>
</ul>
<p>假设一个类变量的定义为: public static int value &#x3D; 3;</p>
<p>那么变量value在准备阶段过后的初始化默认值就是0，而不是3，因为这个时候尚未开始执行任何java方法，而把value赋值为3的public static指令是在程序编译后，存放在类构造器&lt;clinit&gt;()方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p>
<blockquote>
<p>这里还需要注意如下几点：</p>
<ul>
<li>对基本数据类型来说，对应类变量和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li>
<li>对于同时被static和final修饰的常量，必须在声明的时候就为其显式的赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li>
<li>对于引用数据类型reference来说，如数组引用，对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</li>
<li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li>
</ul>
</blockquote>
<ul>
<li>如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstantValue属性所指定的值。在初始化阶段就不会再次被初始化了，即不会在&lt;clinit&gt;()中在次赋值，而如果是final static修饰的引用类型变量就会生成&lt;clinit&gt;()并在初始化阶段执行。</li>
</ul>
<p>假设上面的类变量value被定义为： public static final int value &#x3D; 3;</p>
<p>编译时javac就会将value生成ConstantValue属性，在准备阶段虚拟机j就会根据ConstantValue的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的常量池中。</p>
<p><strong>解析: 把类中的符号引用转换为直接引用</strong></p>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或者接口，字段，类方法，接口方法，方法类型，方法句柄和调用点限定符7类符合引用进行。符合引用就是一组符合来描述目标，可以是任何字面量。</p>
<p>直接引用就是直接指向目标的指针，相对偏移量或者一个间接定位到目标的句柄。</p>
<p><strong>初始化</strong></p>
<p>类初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的java程序代码，在准备阶段，类变量已经被赋过一次系统要求的默认值，而在初始化阶段，则是根据程序指定的主观计划去初始化变量和其它资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程。</p>
<p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化，在Java中对类变量进行初始值设定有两种方式：</p>
<ol>
<li>声明类变量的初始指定值</li>
<li>使用静态代码块为类变量指定初始值</li>
</ol>
<p>JVM初始化步骤:</p>
<ul>
<li>假如这个类还没有被加载或者连接，则程序先加载并连接该类</li>
<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ul>
<p>java虚拟机规范为类的初始化时机做了严格定义：&quot;initialize on first active user&quot;, 在首次主动使用时初始化；</p>
<p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p>
<ul>
<li>创建类的实例，也就是new的方式</li>
<li>访问某个类或者接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射 (如Class.forName(&quot;com.hualala.shop.Test&quot;))，但它有可能导致ClassNotFoundException</li>
<li>初始化某个类的子类，则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动的类(Java Test), 直接使用java命令来运行某个主类</li>
<li>静态域被访问，而且不是常量，即不是被static final修饰的字段。</li>
<li>在顶层类中执行assert语句。</li>
</ul>
<p>初始化阶段主要执行类构造器&lt;clinit&gt;()方法。&lt;clinit&gt;()方法是由编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，则前面的静态代码块中可以赋值，但是不能访问，另外需要注意以下几个比较重要的地方：</p>
<ol>
<li>&lt;clinit&gt;()方法与实例构造器&lt;init&gt;()方法不同，它不需要显式地调用父类构造器，虚拟机会保证子类的&lt;clinit&gt;()方法执行前，父类的&lt;clinit&gt;()方法已经执行完毕，因此，在虚拟机中第一个被执行的&lt;clinit&gt;()方法的类肯定是java.lang.Object.</li>
<li>&lt;clinit&gt;()是在类初始化时候执行的，所以当一个类实例化是肯定要保证这个类被正确的加载(包括类加载，连接，初始化), 所以&lt;clinit&gt;()肯定优先于实例构造器&lt;init&gt;();</li>
<li>&lt;clinit&gt;()方法对于类或者接口来说不是必须的，如果一个类中没有静态代码块，也就没有对类变量的赋值操作，那么编译器可以不为这个类生成&lt;clinit&gt;()方法。</li>
<li>接口中不能使用静态代码块，但仍然有类变量(final static修饰，且非ConstValue属性常量)初始化的复制操作，因此接口和类一样会生成&lt;clinit&gt;()方法，但是接口类的不同的是：执行接口的&lt;clinit&gt;()方法不需要先执行父接口的&lt;clinit&gt;()方法，只有当父接口中定义的变量被使用时，父接口才会被初始化，另外，接口的实现类在初始化时也一样不会执行接口的&lt;clinit&gt;()方法。只有当接口的静态变量被使用时才会被初始化，所以可以基于这种机制来实现一种单例模式的写法：</li>
</ol>
<ul>
<li>虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确地加锁和同步，如果多个线程同时初始化一个类，那么只会有一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待，直到活跃线程执行&lt;clinit&gt;()方法完毕后，如果在一个类的&lt;clinit&gt;()方法中有很耗时的操作，那么就可能造成多个线程阻塞，在实际应用中这种阻塞是很隐蔽的，以下的单例模式的写法就是根据类加载机制的线程安全性来实现单例模式的初始化。</li>
</ul>
<p><strong>可以使用javap -v 字节码文件验证</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类初始化总结：</p>
<ul>
<li>类初始化的过程就是在类的静态变量已经被准备阶段赋予默认的零值之后重新赋值或者初始化过程，即&lt;clinit&gt;()方法的执行过程。</li>
<li>&lt;clinit&gt;()是有编译器编译代码时安装代码编写顺序收集类的静态变量赋值和静态代码块的集合</li>
<li>&lt;clinit&gt;()在类或者接口首次访问时初始(包括类Class.forName，new实例，反射，newInstance()，静态变量的访问和赋值，静态方法被访问)时执行。</li>
<li>子类的&lt;clinit&gt;()晚于父类的&lt;clinit&gt;(), 即执行子类的&lt;clinit&gt;()会触发父类的&lt;clinit&gt;()执行。</li>
<li>接口和类一样也可以有静态变量(接口中字段不修饰默认就是static), 但是不能有静态代码块，所以也会编译器初始化接口时也会生成&lt;clinit&gt;()方法，与类不同的是接口的&lt;clinit&gt;()执行不会触发父接口的&lt;clinit&gt;()执行，接口的实现类也不会触发接口的&lt;clinit&gt;()。</li>
<li>&lt;clinit&gt;()执行是多线程安全的。</li>
</ul>
<p><strong>结束生命周期</strong></p>
<p>在如下几种情况下，Java虚拟机将结束生命周期</p>
<ul>
<li>执行了System.exit()方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或者错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ul>
<h1 id="类缓存"><a href="#类缓存" class="headerlink" title="类缓存"></a>类缓存</h1><p>我们知道标准的javase类加载器可以按照要求来查找类，一旦某个类被加载到类加载器中，它将维持加载(也就是缓存)一段时间。在有方法被调用的时候，一般都是直接在缓存中直接获取该类并创建它的一个副本引用。</p>
<p>需要注意的是，虽然有类缓存的存在可以是性能提高，但JVM中的垃圾回收机还是会回收这些Class对象的。</p>
<p><strong>一般来说，类都只被加载了一次!</strong></p>
<p>一个简单的测试demo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        // 当A对象被创建的时候，先会执行静态代码块，在执行A的构造方法</span><br><span class="line">        A a = new A();</span><br><span class="line">        System.out.println(a.width); // 输出顺序为 创建初始化类A--&gt; 创建A对象 --&gt; width = 300</span><br><span class="line">        </span><br><span class="line">        // 只会打印 创建A对象，不会在加载第二次</span><br><span class="line">        A a2 = new A();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private class A &#123;</span><br><span class="line">        public static int width = 100;</span><br><span class="line">        public static final int MAX = 200;</span><br><span class="line">        </span><br><span class="line">        static &#123;</span><br><span class="line">            System.out.println(&quot;静态初始化A类&quot;);</span><br><span class="line">            width = 300;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public A()&#123;</span><br><span class="line">            System.out.println(&quot;创建A对象&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="对象在内存中存储"><a href="#对象在内存中存储" class="headerlink" title="对象在内存中存储"></a>对象在内存中存储</h1><p>在Hotspot虚拟机中，对象在内存中的存储也是很有规律的，存储的布局可以分为三块区域：对象头区域，实例数据区域和对其填充区域。</p>
<p>对象头的一部分用于存储对象自身运行时的数据，另外部分存储的是类型指针，即对象指向类元数据指针，虚拟机通过这个指针来确定这个对象属于那个类。</p>
<p>实例数据区是对象存储的真正有效的信息，即在程序中定义的各种类型的字段数据，这部分数据有一部分是从父类继承过来的，也有在子类中定义的。</p>
<p>对其填充并不一定是必然存在的，因为Hotspot虚拟机内存管理的要求是给对象分配内存大小必须是8字节的整数倍，所以不够的部分需要填充。又因为对象头部信息正好是8字节的整数倍，所以对其填充补全的是实例数据区域，对其填充的数据并没有特殊的含义，仅仅是起到填充占位符的作用。</p>
<h2 id="计算对象在内存中占用的空间大小"><a href="#计算对象在内存中占用的空间大小" class="headerlink" title="计算对象在内存中占用的空间大小"></a>计算对象在内存中占用的空间大小</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.ypb.codetest.sizeofobject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: SizeOfObject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 测试一个对象占用多少字节(对象占用字节大小工具类)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangpengbing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-28-10:50</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SizeOfObject</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> Instrumentation inst;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String args, Instrumentation instP)</span> &#123;</span><br><span class="line">		inst = instP;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 直接计算当前对象占用空间的大小，包括当前类及超类的基本类型实例字段的大小</span></span><br><span class="line"><span class="comment">	 * 引用类型实例字段引用大小，实例基本类型数组占用空间大小，实例引用类型数组引用本身占用空间大小</span></span><br><span class="line"><span class="comment">	 * 但是不包括超类继承下来的和当前类声明的实例引用字段的对象本身的大小，实例引用数组的对象本身的大小</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sizeOf</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> inst.getObjectSize(obj);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">fullSizeOf</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalAccessException &#123;</span><br><span class="line">		Set&lt;Object&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		Deque&lt;Object&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">		deque.add(obj);</span><br><span class="line"></span><br><span class="line">		<span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (deque.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> deque.poll();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// sizeOf的时候已经计算基本类型和引用的长度，包括数组</span></span><br><span class="line">			size += skipObject(visited, o) ? <span class="number">0L</span> : sizeOf(o);</span><br><span class="line"></span><br><span class="line">			Class&lt;?&gt; clazz = o.getClass();</span><br><span class="line">			<span class="keyword">if</span> (clazz.isArray()) &#123;</span><br><span class="line">				<span class="comment">// [I, [F 基本类型名字长度是2</span></span><br><span class="line">				<span class="keyword">if</span> (clazz.getName().length() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, len = Array.getLength(o); i &lt; len; i++) &#123;</span><br><span class="line">						<span class="type">Object</span> <span class="variable">temp</span> <span class="operator">=</span> Array.get(o, i);</span><br><span class="line">						<span class="keyword">if</span> (Objects.nonNull(temp)) &#123;</span><br><span class="line">							<span class="comment">// 非基本类型需要深度遍历其对象</span></span><br><span class="line">							deque.add(temp);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">while</span> (Objects.nonNull(clazz)) &#123;</span><br><span class="line">					Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">					<span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">						<span class="comment">// 静态不计，基本类型不重复计算</span></span><br><span class="line">						<span class="keyword">if</span> (Modifier.isStatic(field.getModifiers()) || field.getType().isPrimitive()) &#123;</span><br><span class="line">							<span class="keyword">continue</span>;</span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">						field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">						<span class="type">Object</span> <span class="variable">fieldValue</span> <span class="operator">=</span> field.get(o);</span><br><span class="line">						<span class="keyword">if</span> (Objects.isNull(fieldValue)) &#123;</span><br><span class="line">							<span class="keyword">continue</span>;</span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">						deque.add(fieldValue);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					clazz = clazz.getSuperclass();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * String.intern的对象不计，计算过的不计，也避免死循环</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> visited</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">skipObject</span><span class="params">(Set&lt;Object&gt; visited, Object obj)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String &amp;&amp; obj == ((String) obj).intern()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> visited.contains(obj);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.ypb.codetest.sizeofobject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SizeOfObjectTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * -XX:-UseCompressedOops(关闭指针压缩): sizeOf(new A()) = 24 = 16(header) + 4(instance data) + 4(padding)</span></span><br><span class="line"><span class="comment">	 *      推导过程：new A(), 普通对象引用，没有开启压缩，对象头16个字节，基本数据类型int 4个字节，16+4=20, 不能被8整除，需要padding填充对其，</span></span><br><span class="line"><span class="comment">	 *          而padding的字节数是[0, 8) 3*8 = 24 - 20 = 4，所以padding填充对其的字节数是4</span></span><br><span class="line"><span class="comment">	 * -XX:+UseCompressedOops(开启指针压缩): sizeOf(new A()) = 16 = 12(header) + 4(instance data) + 0(padding)</span></span><br><span class="line"><span class="comment">	 *      推导过程：new A()，普通对象引用， 开启压缩，对象头是12个字节，基本数据类型int 4个字段， 12+4 = 16, 能被8整除，故padding为0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">		<span class="type">int</span> a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * -XX:-UseCompressedOops: sizeOf(new B()) = 24 = 16(header) + (4+4)(instance data) + 0(padding)</span></span><br><span class="line"><span class="comment">	 * -XX:+UseCompressedOops: sizeOf(new B()) = 24 = 12(header) + (4+4)(instance data) + 4(padding)</span></span><br><span class="line"><span class="comment">	 * -------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">	 * -XX:-UseCompressedOops: sizeOf(new B[3]) = 24(header) + 3*8(instance data) = 24+24 + 0(padding) = 48</span></span><br><span class="line"><span class="comment">	 *      推导过程：new B[3] 未开启压缩：数组对象头(24)，引用类型, 数组长度3(3*8) = 24+24 + 0(padding)</span></span><br><span class="line"><span class="comment">	 * -XX:+UseCompressedOops: sizeOf(new B[3]) = 16(header) + 3*4(instance data) = 16+12 + 4(padding) = 32</span></span><br><span class="line"><span class="comment">	 *      推导过程：new B[3] 开启压缩，数组对象头(16)，引用类型，数组长度为3(4*3) = 16+12 + 4(padding)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">		<span class="type">int</span> a;</span><br><span class="line">		<span class="type">int</span> b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * -XX:-UseCompressedOops: sizeOf(new B2()) = 16(header) + (4(int) + 8(Integer))(instance data) = 28 + 4(padding) = 32(4 * 8)</span></span><br><span class="line"><span class="comment">	 *      推导过程：new B2() 未开启指针压缩: 普通对象头(16), 基本数据类型int(4), reference引用类型，未开启压缩(8) = 16 + 4 + 8 = 28 + 4(padding) = 4*8</span></span><br><span class="line"><span class="comment">	 * -XX:+UseCompressedOops: sizeOf(new B2()) = 12(header) + (4 + 4)(instance data) = 20 + 4(padding) = 24(8 * 3)</span></span><br><span class="line"><span class="comment">	 *      推导过程：new B2(), 开启指针压缩：普通对象头(12), 基本数据类型int(4), reference引用类型，开启压缩(4) = 12 + 4 + 4 = 20 + 4(padding) = 3*8;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B2</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> b2a;</span><br><span class="line">		Integer b2b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * -XX:-UseCompressedOops: sizeOf(new C()) = 16(header) + (4+8+4)(instance data) = 40 ???</span></span><br><span class="line"><span class="comment">	 *  16(header) + (4(a)+4(ba)+8(as))(instance data) = 16+ 16 = 32 + 0(padding)</span></span><br><span class="line"><span class="comment">	 * // TODO 这个计算和RamUsageEstimator.shallowSizeOf(new C())在相同的情况下计算的结果不一致。 sizeOf计算的是40，另一个计算的是32</span></span><br><span class="line"><span class="comment">	 * -XX:+UseCompressedOops: sizeOf(new C()) = 12(header) + (4+4+4)(instance date) = 24 + 0(padding) = 24</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> ba;</span><br><span class="line">		B[] as = <span class="keyword">new</span> <span class="title class_">B</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">C</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; i++) &#123;</span><br><span class="line">				as[i] = <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * -XX:-UseCompressedOops: sizeOf(new C1()) = 16(header) + (4+8)(instance data) = 28 + 4(padding) = 32</span></span><br><span class="line"><span class="comment">	 * -XX:+UseCompressedOops: sizeOf(new C1()) = 12(header) + (4+4)(instance data) = 20 + 4(padding) = 24</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">C1</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> ba;</span><br><span class="line">		B[] bs = <span class="keyword">new</span> <span class="title class_">B</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">C1</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bs.length; i++) &#123;</span><br><span class="line">				bs[i] = <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * -XX:-UseCompressedOops: sizeOf(new C2()) = 16(header) + (4+8+4+4)(instance data) = 36 + 4(padding) = 40</span></span><br><span class="line"><span class="comment">	 * -XX:+UseCompressedOops: sizeOf(new C2()) = 12(header) + (4+4+4+4)(instance data) = 28 + 4(padding) = 32</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">C2</span> <span class="keyword">extends</span> <span class="title class_">B</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> ba;</span><br><span class="line">		B[] bs = <span class="keyword">new</span> <span class="title class_">B</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">C2</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bs.length; i++) &#123;</span><br><span class="line">				bs[i] = <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * -XX:-UseCompressedOops: sizeOf(new C3()) = 16(header) + 8(Instance data) + 0(padding) = 24</span></span><br><span class="line"><span class="comment">	 * -XX:+UseCompressedOops: sizeOf(new C3()) = 12(header) + 4(Instance data) + 0(padding) = 16</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">C3</span> &#123;</span><br><span class="line"></span><br><span class="line">		B[] bs = <span class="keyword">new</span> <span class="title class_">B</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">C3</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bs.length; i++) &#123;</span><br><span class="line">				bs[i] = <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * -XX:-UseCompressedOops: sizeOf(new D()) = 16(header) + (4+8+4+4)(Instance data) = 36 + 4(padding) = 40</span></span><br><span class="line"><span class="comment">	 * -XX:+UseCompressedOops: sizeOf(new D()) = 12(header) + (4+4+4+4)(Instance data) = 28 + 4(padding) = 32</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">B</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> da;</span><br><span class="line">		Integer[] di = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">3</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * -XX:-UseCompressedOops: sizeOf(new E()) = 16(header) + (4+4+4)(instance data) = 16+12 + 4(padding) = 32</span></span><br><span class="line"><span class="comment">	 * -XX:+UseCompressedOops: sizeOf(new E()) = 12(header) + (4+4+4)(instance data) = 12+12 + 0(padding) = 24</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">E</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> ea;</span><br><span class="line">		<span class="type">int</span> eb;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * java -javaagent:./target/test.jar -XX:-UseCompressedOops -classpath ./target/test.jar com.ypb.codetest.sizeofobject.SizeOfObjectTest</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException &#123;</span><br><span class="line"><span class="comment">//		C c = new C();</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;RamUsageEstimator.shallowSizeOf(new C()) = &quot; + RamUsageEstimator.shallowSizeOf(c));</span></span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;SizeOfObject.sizeOf(new C()) = &quot;</span> + SizeOfObject.sizeOf(<span class="keyword">new</span> <span class="title class_">C</span>()));</span><br><span class="line">		System.out.println(<span class="string">&quot;SizeOfObject.sizeOf(new C1()) = &quot;</span> + SizeOfObject.sizeOf(<span class="keyword">new</span> <span class="title class_">C1</span>()));</span><br><span class="line">		System.out.println(<span class="string">&quot;SizeOfObject.sizeOf(new C2()) = &quot;</span> + SizeOfObject.sizeOf(<span class="keyword">new</span> <span class="title class_">C2</span>()));</span><br><span class="line">		System.out.println(<span class="string">&quot;SizeOfObject.sizeOf(new C3()) = &quot;</span> + SizeOfObject.sizeOf(<span class="keyword">new</span> <span class="title class_">C3</span>()));</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./target/classes&quot;</span>).getAbsolutePath());</span><br><span class="line">		System.out.println(<span class="string">&quot;SizeOfObject.sizeOf(new Object()) = &quot;</span> + SizeOfObject.sizeOf(<span class="keyword">new</span> <span class="title class_">Object</span>()));</span><br><span class="line">		System.out.println(<span class="string">&quot;SizeOfObject.sizeOf(new A()) = &quot;</span> + SizeOfObject.sizeOf(<span class="keyword">new</span> <span class="title class_">A</span>()));</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;SizeOfObject.sizeOf(new B()) = &quot;</span> + SizeOfObject.sizeOf(<span class="keyword">new</span> <span class="title class_">B</span>()));</span><br><span class="line">		System.out.println(<span class="string">&quot;SizeOfObject.sizeOf(new B2()) = &quot;</span> + SizeOfObject.sizeOf(<span class="keyword">new</span> <span class="title class_">B2</span>()));</span><br><span class="line">		System.out.println(<span class="string">&quot;SizeOfObject.sizeOf(new B[3]) = &quot;</span> + SizeOfObject.sizeOf(<span class="keyword">new</span> <span class="title class_">B</span>[<span class="number">3</span>]));</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;SizeOfObject.sizeOf(new C()) = &quot;</span> + SizeOfObject.sizeOf(<span class="keyword">new</span> <span class="title class_">C</span>()));</span><br><span class="line">		System.out.println(<span class="string">&quot;SizeOfObject.fullSizeOf(new C()) = &quot;</span> + SizeOfObject.fullSizeOf(<span class="keyword">new</span> <span class="title class_">C</span>()));</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;SizeOfObject.sizeOf(new D()) = &quot;</span> + SizeOfObject.sizeOf(<span class="keyword">new</span> <span class="title class_">D</span>()));</span><br><span class="line">		System.out.println(<span class="string">&quot;SizeOfObject.fullSizeOf(new D()) = &quot;</span> + SizeOfObject.fullSizeOf(<span class="keyword">new</span> <span class="title class_">D</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//		-XX:-UseCompressedOops: sizeOf(new int[3]) = 24(header) + (4*3)(instance data) = 24 + 12 + 4(padding) = 40</span></span><br><span class="line"><span class="comment">//		-XX:+UseCompressedOops: sizeOf(new int[3]) = 16(header) + (4*3)(instance data) = 16 + 12 + 4(padding) = 32</span></span><br><span class="line">		System.out.println(<span class="string">&quot;SizeOfObject.sizeOf(new int[3]) = &quot;</span> + SizeOfObject.sizeOf(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">//		-XX:-UseCompressedOops: sizeOf(new Integer(1)) = 16(header) + (4)(instance data) = 16 + 4 + 4(padding) = 24</span></span><br><span class="line"><span class="comment">//		-XX:+UseCompressedOops: sizeOf(new Integer(1)) = 12(header) + (4)(instance data) = 12 + 4 + 0(padding) = 16</span></span><br><span class="line">		System.out.println(<span class="string">&quot;SizeOfObject.sizeOf(new Integer(1)) = &quot;</span> + SizeOfObject.sizeOf(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>)));</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//		-XX:-UseCompressedOops: sizeOf(new Integer[0]) = 24(header) + (0)(instance data) = 24 + 0 + 0(padding) = 24</span></span><br><span class="line"><span class="comment">//		-XX:+UseCompressedOops: sizeOf(new Integer[0]) = 16(header) + (0)(instance data) = 16 + 0 + 0(padding) = 16</span></span><br><span class="line">		System.out.println(<span class="string">&quot;SizeOfObject.sizeOf(new Integer[0]) = &quot;</span> + SizeOfObject.sizeOf(<span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">//		-XX:-UseCompressedOops: sizeOf(new Integer[1]) = 24(header) + (4)(instance data) = 24 + 4 + 4(padding) = 32</span></span><br><span class="line"><span class="comment">//		-XX:+UseCompressedOops: sizeOf(new Integer[1]) = 16(header) + (4)(instance data) = 16 + 4 + 4(padding) = 24</span></span><br><span class="line">		System.out.println(<span class="string">&quot;SizeOfObject.sizeOf(new Integer[1]) = &quot;</span> + SizeOfObject.sizeOf(<span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">//		-XX:-UseCompressedOops: sizeOf(new Integer[2]) = 24(header) + (4*2)(instance data) = 24 + 8 + 0(padding) = 32</span></span><br><span class="line"><span class="comment">//		-XX:+UseCompressedOops: sizeOf(new Integer[2]) = 16(header) + (4*2)(instance data) = 16 + 8 + 0(padding) = 24</span></span><br><span class="line">		System.out.println(<span class="string">&quot;SizeOfObject.sizeOf(new Integer[2]) = &quot;</span> + SizeOfObject.sizeOf(<span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">//		System.out.println(&quot;SizeOfObject.sizeOf(new Integer[3]) = &quot; + SizeOfObject.sizeOf(new Integer[3]));</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;SizeOfObject.sizeOf(new Integer[4]) = &quot; + SizeOfObject.sizeOf(new Integer[4]));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//		-XX:-UseCompressedOops: sizeOf(new A[3]) = 24(header) + (4*3)(instance data) = 24 + 12 + 4(padding) = 40</span></span><br><span class="line"><span class="comment">//		-XX:+UseCompressedOops: sizeOf(new A[3]) = 16(header) + (4*3)(instance data) = 16 + 12 + 4(padding) = 32</span></span><br><span class="line">		System.out.println(<span class="string">&quot;SizeOfObject.sizeOf(new A[3]) = &quot;</span> + SizeOfObject.sizeOf(<span class="keyword">new</span> <span class="title class_">A</span>[<span class="number">3</span>]));</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;SizeOfObject.sizeOf(new E()) = &quot;</span> + SizeOfObject.sizeOf(<span class="keyword">new</span> <span class="title class_">E</span>()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**************************** 学习笔记(2019年4月28日) ******************************/</span></span><br><span class="line"><span class="comment">//	Java对象的内存布局：对象头(header)，实例数据(instance data)和对齐填充(padding)， 不同环境结果可能存在差异，我所在的环境是64为hotspot虚拟机，64位的windows系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	对象头： 对象头在32位操作系统上是8bytes，64位操作系统是16bytes  eg: SizeOfObject.sizeOf(new Object());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	实例数据：</span></span><br><span class="line"><span class="comment">//		基本类型(primitive type)的内存占用如下：</span></span><br><span class="line"><span class="comment">//		+-------------------+--------------------------------------------+------------------------------------+</span></span><br><span class="line"><span class="comment">//	    |   primitive type  |   memory required(bytes字节)(64位无压缩)     |  64位压缩(-XX:+UseCompressedOops)  |</span></span><br><span class="line"><span class="comment">//		+-------------------+--------------------------------------------+------------------------------------+</span></span><br><span class="line"><span class="comment">//		|   boolean         |   1                                        |   1                                |</span></span><br><span class="line"><span class="comment">//		+-------------------+---------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">//	    |   byte            |   1                                        |   1                                |</span></span><br><span class="line"><span class="comment">//	    +-------------------+---------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">//		|   short           |   2                                        |   2                                |</span></span><br><span class="line"><span class="comment">//		+-------------------+---------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">//		|   char            |   2                                        |   2                                |</span></span><br><span class="line"><span class="comment">//	    +-------------------+---------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">//	    |   int             |   4                                        |   4                                |</span></span><br><span class="line"><span class="comment">//		+-------------------+---------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">//		|   float           |   4                                        |   4                                |</span></span><br><span class="line"><span class="comment">//	    +-------------------+---------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">//		|   long            |   8                                        |   8                                |</span></span><br><span class="line"><span class="comment">//	    +-------------------+---------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">//      |   double          |   8                                        |   8                                |</span></span><br><span class="line"><span class="comment">//	    +-------------------+---------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">//	    |   普通对象头       |   16                                       |  12                                |</span></span><br><span class="line"><span class="comment">//		+-------------------+---------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">//		|   数组对象头       |   24                                       |  16                                |</span></span><br><span class="line"><span class="comment">//	    +-------------------+---------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">//		|   reference(引用) |    8                                       |   4                                |</span></span><br><span class="line"><span class="comment">//	    +-----------------------------------------------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	    reference类型在32位系统上是4个字节，在64位系统上是8个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	对其填充：</span></span><br><span class="line"><span class="comment">//		hotspot的对其方式为8字节对齐</span></span><br><span class="line"><span class="comment">//		(对象头+实例数据+padding) % 8  = 0 &amp;&amp; 0 &lt;= padding &lt; 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	计算对象本身占用的大小和对象总空间占用的大小的区别：</span></span><br><span class="line"><span class="comment">//		1. 本身占用的大小，对象中除了基本类型之外，其他类型都按照引用类型来计算，不要计算引用中的对象的大小</span></span><br><span class="line"><span class="comment">//	    2. 总空间占用的大小，要计算对象中每一个对象的大小，引用中的对象也需要计算，在累加活动总空间。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	对象本身的大小</span></span><br><span class="line"><span class="comment">//	    直接计算当前对象占用空间大小，包括当前类以及父类的基本类型实例字段大小，引用类型实例字段大小，实例基本类型数组大小总占用空间，实例引用类型数组本身占用的大小，</span></span><br><span class="line"><span class="comment">//	    但不包括父类继承下来的h饿当前类声明的实例引用的对象本身的大小，实例引用数组引用的对象本身的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	当前对象占用的空间总大小</span></span><br><span class="line"><span class="comment">//	    递归计算当前对象占用空间总大小，包括当前类和父类的实例字段大小以及实字段引用对象大小</span></span><br><span class="line"><span class="comment">//		递归计算复合对象占用的内存的时候需要注意的是：对齐填充是以每个对象为单位进行的 https://images0.cnblogs.com/i/288950/201405/281956463229130.png</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="访问对象"><a href="#访问对象" class="headerlink" title="访问对象"></a>访问对象</h1><p>我们创建对象的目的就是为了使用对象，那么如何访问一个对象呢，我们知道java虚拟机栈中的局部变量表，存放的数据处理基本的数据类型以外，还有对象引用(reference)类型。引用类型比较特殊，在java虚拟机规范中，只是规定这是指向一个对象的引用，但并没有规定这个类型的具体实现，也即是如何定位对象，访问对象在堆中的具体位置，在不同的虚拟机中，对象的访问方式也是不同的，主流的1访问方式有<strong>使用句柄</strong>和<strong>直接指针</strong>两种。</p>
<p><strong>使用句柄</strong></p>
<p><img src="/jvm/learn-jvm-001/%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.jpg" loading="lazy"></p>
<p>如果使用句柄访问方式，将会在堆中划分一块内存区域作为句柄池。如上图所示，reference中存储的是对象的句柄地址，而句柄中包含的才是对象实例和对象类型各自的具体地址，所以可以看出，使用句柄是一种间接使用指针访问对象和方式。</p>
<p><strong>直接指针</strong></p>
<p><img src="/jvm/learn-jvm-001/%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.jpg" loading="lazy"></p>
<p>如果使用直接指针访问方式，java堆就必须考虑如何放置访问对象有关的信息，reference中直接存储的是对象地址。</p>
<p>两种访问方式各有优势：使用句柄访问方式的最大好处是reference中存储的是稳定的句柄地址，在对象被移动时只需要改变句柄中的对象类型数据指针，而reference本身不需要被修改，而使用直接指针访问方式最大的好处就是速度更快，他节省了一次指针定位的时间开销。在Hotspot虚拟机中采用的是第二中访问方式，但使用句柄方式来访问的情况在软件开发中也很常见。</p>
<blockquote>
<p><strong>小结</strong><br>Java堆就像是游戏玩家出生的新手村，承载着一个对象来的java世界的梦想，资源分配，初始的装备，以及对象的区分和查找，每一步都和对象以后的命运息息相关。</p>
</blockquote>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>寻找类加载器，先来看一个小例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hualala.test.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        System.out.println(loader.getParent());</span><br><span class="line">        System.out.println(loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后，输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.launcher$AppClassLoader@64fef26a</span><br><span class="line">sum.misc.launcher$ExtClassLoader@1ddd40f3</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<p>从上面的结果可以看出，并没有获取到ExtClassLoader的父Loader，原因是Bootstrap ClassLoader(引导类加载器)是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回null。</p>
<p>这几种类加载器的层次关系如下图所示：</p>
<p><img src="/jvm/learn-jvm-001/calssloader.png" alt="img" loading="lazy"></p>
<blockquote>
<p>注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p>
</blockquote>
<p>站在java虚拟机的角度讲，只存在两种不同的类加载器：</p>
<p><strong>启动类加载器：</strong> 它使用C++实现的(这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用java实现的)，是虚拟机自身的一部分；</p>
<p><strong>所有其他的类加载器：</strong> 这些类加载器都由java语言实现的，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载需要有启动加载器加载到内存中之后才能去加载其他的类。</p>
<p>站在java开发人员角度来看，类加载器可以大致分为三类：</p>
<p><strong>启动类加载器：</strong> Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表的是JDK的安装目录)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar, 所有的java.开头的类均被Bootstrap ClassLoaderj加载)。启动类加载器是无法被Java程序直接引用的.</p>
<p><strong>扩展类加载器：</strong> Extension ClassLoader，该加载由sum.misc.launcher$ExtClassLoader实现，它负责加载JDk\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.开头的类), 开发这可以直接使用扩展类加载器.</p>
<p><strong>应用程序类加载器：</strong> Application ClassLoader，该类加载器有sum.misc.launcher$AppClassLoader来实现，它负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用这个类加载器，如果应用程序中没有定义过自己的类加载器，一般情况下这个就是程序默认的类加载器。</p>
<p>应用程序都是由这三种类加载器相互配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p>
<ul>
<li>在执行非置信代码之前，自动验证数字签名。</li>
<li>动态的创建符合用户特定需要的定制化构建类</li>
<li>从特定的场所获取java class，比如数据库中和网络中</li>
</ul>
<p>java类加载器有两个比较重要的特征：层次组织结构和代理模式。层次组织结构值得是每个类加载器都有一个父类加载器，通过getParent()方法可以获取到，类加载器通过这种父亲-后代的方式组织在一起，形成树状层次结构。代理模式则指的是通过一个类加载器既可以自己完成java类的定义工作，也可以代理给其它的类加载器来完成。由于这种代理模式的存在，启动一个类的加载过程和最终定义这个类的类加载器可能并不是一个，前者称为初始类加载器，而后者称为定义类加载器，两者的关联在于：一个java类的定义类加载器是该类所导入的其它java类的初始类加载器，比如类A通过import导入了B类，那么有类A的定义加载器负责启动类B的加载过程。</p>
<p><strong>JVM类加载机制</strong></p>
<ul>
<li><strong>全盘负责</strong> 当一个类加载器负责加载某个Class文件时，该Class所依赖的和引用的其他Class也将由该类加载器负责加载。除非显示使用另外一个类加载器来载入。</li>
<li><strong>父类委托</strong> 先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li>
<li><strong>缓存机制</strong> 缓存机制将会保证所有已经加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区，这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li>
</ul>
<h1 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h1><p>类的加载是通过类加载器(ClassLoader)完成的，它既可以是饿汉式<a href="%E5%8F%AA%E8%A6%81%E6%9C%89%E5%85%B6%E4%BB%96%E7%B1%BB%E5%BC%95%E7%94%A8%E4%BA%86%E5%AE%83%E5%B0%B1%E5%8A%A0%E8%BD%BD">eagerly load</a>加载类，也可以是懒汉式<a href="%E7%AD%89%E5%88%B0%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%91%E7%94%9F%E7%9A%84%E6%97%B6%E5%80%99%E6%89%8D%E5%8A%A0%E8%BD%BD">lazy load</a>。这跟不同的JVM虚拟机实现有关，然而它又是受JLS保证的(当有静态初始化需求的时候才被加载).</p>
<p>类加载器有三种方式：</p>
<ol>
<li>命令行启动应用时候有JVM初始化加载。</li>
<li>通过Class.forName()方法动态加载。</li>
<li>通过ClassLoader.loadClass()方法动态加载。</li>
</ol>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hualala.test.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> HelloWorld.class.getClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用ClassLoader.loadClass()来加载类，不会执行初始化块</span></span><br><span class="line">        loader.loadClass(<span class="string">&quot;Test2&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用Class.forName()来加载类，默认会执行初始化块</span></span><br><span class="line">        Class.forName(<span class="string">&quot;Test2&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用Class.forName()加载类，并指定ClassLoader，初始化不会执行静态代码块</span></span><br><span class="line">        Class.forName(<span class="string">&quot;Test2&quot;</span>, <span class="literal">false</span>, loader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dmeo类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别切换加载方式，会有不同的输出结果。</p>
<p><strong>Class.forName()和ClassLoader.loadClass()区别</strong></p>
<ul>
<li>Class.forName(): 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类的static块。</li>
<li>ClassLoader.loadClass(): 只干一件事情，就是把.class文件加载到jvm之中，不会执行类中的static块。只有在newInstance才会去执行static代码块。</li>
<li>Class.forName(name, initialize, loader): 带参数也可控制是否加载static代码块，并且只有调用了newInstance()方法采用调用构造函数，创建类的对象。</li>
</ul>
<h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><p><img src="/jvm/learn-jvm-001/14423059-54897a5d741e7f0e.png" loading="lazy"></p>
<p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委派给父加载器去完成，依次向上，因此，所有的类价值请求最终都会应该被传递到顶层的启动类加载器中，只有当父加载器在加载它的搜索范围内中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>
<p>双亲委派机制：</p>
<ol>
<li>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把加载请求委派给父加载器ExtClassLoader去完成。</li>
<li>当ExtClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把加载请求委派给BootstrapClassLoader去完成。</li>
<li>如果BootstrapClassLoader加载失败(例如在$JAVA_HOME&#x2F;jre&#x2F;lib里为找到该class)，会使用ExtClassLoader来尝试加载；</li>
<li>如ExtClassLoader也加载失败，这会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</li>
</ol>
<p>ClassLoader源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 首先判断该类型是否已经被加载过</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果没有被加载，就委派给父类加载器或者委派给启动类加载器加载</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果存在父类加载器，就会委派给父类加载器加载</span></span><br><span class="line">                c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果不存在父类加载器，就检查是否由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name);</span></span><br><span class="line">                </span><br><span class="line">                c = findBoostrapClass0(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 如果父类加载器和启动类加载器都不完能任务，才调用自身的加载功能</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(resolve) &#123;</span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双亲委派模型的意义：</p>
<ul>
<li>系统类防止内存中出现多份同样的字节码</li>
<li>保证java程序安全稳定运行</li>
<li>双亲委派机制是为了保证JAVA核心库的类型安全(这种机制保证了不会出现用户能自定义java.lang.Object类的情况). 保证核心类无法被用户定义</li>
</ul>
<h1 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h1><p>通常情况下，我们都是直接使用系统类加载器，但是，有时候，我们也需要自定义类加载器，比如应用的是通过网络来传输java类的字节码，为了保证安全性，这些字节码经过了加密处理，这时类加载器就无法对其进行加载，这样这需要自定义类加载器来实现，自定义类加载器一般都是继承ClassLoader类，从上面对loadClass方法来分析来看，我们只需要重写findClass方法即可，下面我们通过一个实例来演示自定义类加载器的流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hualala.test.classloader;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">byte</span>[] classData = loadClassData(name);</span><br><span class="line">        <span class="keyword">if</span>(classData == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> root + File.separatorChar + name.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName);</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">bufferSize</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[bufferSize];</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((length = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baso.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getRoot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(String root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">MyClassLoader</span>();</span><br><span class="line">        loader.setRoot(<span class="string">&quot;E:\\temp&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        Class&lt;?&gt; testClass = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testClass = loader.loadClass(<span class="string">&quot;com.hualala.test.classloader.Test2&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> testClass.newInstance();</span><br><span class="line">            System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密，由于这里只是演示，我并没有对class文件进行加密，因此没有解密的过程，这里有几点需要注意：</p>
<ol>
<li>这么需要传递的文件名需要是类的全限定性名称，即&quot;com.hualala.test.classloader.Test2&quot;格式的，因为defineClass方法是按照这种格式进行处理的。</li>
<li>最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。</li>
<li>这类Test类本身可以被AppClassLoader类加载，因此我们不能把com&#x2F;hualala&#x2F;test&#x2F;classloader&#x2F;Test2.class放在类路径下，否则，由于双亲委托机制的存在，会直接导致该类有AppClassLoader加载，而不会通过我们自定义类加载器加载。</li>
</ol>
<h1 id="了解另外两个类加载器"><a href="#了解另外两个类加载器" class="headerlink" title="了解另外两个类加载器"></a>了解另外两个类加载器</h1><h2 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h2><p>java提供了很多服务提供者接口(Service Provider Interface SPI)，允许第三方为这些接口提供实现，SPI实现的java类一般是由系统类加载来加载的。</p>
<p><strong>双亲委派机制已经类加载器的问题</strong></p>
<ul>
<li>一般情况下，保证同一个类中所关联的其他类都是有当前类的类加载器所加载的。</li>
<li>JDBC API，它有实现的driver部分(mysql，sql server), 我们的JDBC API都是有BOOT或者EXT来载入的，但是JDBC driver却是有EXT或者APP载入的，那么就由可能找不到driver了，在java领域中，其实只要分成这种API+SPI的，都会遇到这种问题。</li>
<li>常见的SPI有JDBC，JCE，JNDI，JAXP和JBI等，这些SPI接口都是有java核心库来提供。比如：JAXP的SPI接口定义包含在javax.xml.parses包中。SPI的接口是java核心库的一部分，是由引导类加载其负责加载的，SPI实现的JAVA类一般是由系统类加载器来加载的，引导类加载器无法找到SPI的具体实现类的，因为它只负责加载java核心库。(系统加载器也叫做应用加载器 System Classloader 或 Application Classloader)</li>
</ul>
<p><strong>线程类加载器是为了抛弃双亲委派加载链模式</strong></p>
<p>每个线程都有一个关联的上下文类加载器，如果你使用new Thread()方式来创建线程，新线程将继承其父线程的上下文类加载器，如果程序对线程上下文加载器没有任何改动的话，程序中所有的线程将使用系统类加载器作为线程上下文加载器</p>
<blockquote>
<ul>
<li>两个方法：</li>
<li><ol>
<li>Thread.currentThread().getContextClassLoader(); &#x2F;&#x2F; 获取线程上下文加载器</li>
</ol>
</li>
<li><ol start="2">
<li>Thread.currentThread().setContextClassLoader(); &#x2F;&#x2F; 设置线程上下文加载器</li>
</ol>
</li>
</ul>
</blockquote>
<p>java默认的线程上下文类加载器是应用类加载器(AppClassLoader)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Now create the class loader to use to launch the application</span><br><span class="line">try &#123;</span><br><span class="line">    loader = AppClassLoader.getAppClassLoader(extcl);</span><br><span class="line">&#125; catch(Exception e)&#123;</span><br><span class="line">    throw new InternalError(&quot;could not create application class loader&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Also set the context class loader for the primordial thread</span><br><span class="line">Thread.currentThread().setContextClassLoader(loader);</span><br></pre></td></tr></table></figure>

<h1 id="Tomcat服务器的类加载器"><a href="#Tomcat服务器的类加载器" class="headerlink" title="Tomcat服务器的类加载器"></a>Tomcat服务器的类加载器</h1><h2 id="tomcat不能使用系统默认的类加载器"><a href="#tomcat不能使用系统默认的类加载器" class="headerlink" title="tomcat不能使用系统默认的类加载器"></a>tomcat不能使用系统默认的类加载器</h2><ul>
<li>如果tomcat跑你的web项目使用的是系统的类加载器是相当危险的，你可以直接操作系统的各个目录了。</li>
<li>对应运行在javaee容器中的web应用来说，类加载器的实现与一般的java应用有所不同。</li>
<li>每个web应用都对应一个类加载器实例，该类加载器也是使用代理模式，所不同的是它首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般的加载器的顺序是相反的，但也是为了安全考虑，这样核心库就不再查询范围之内了。</li>
<li>为了安全tomcat需要实现自己的类加载器(限制你只能把类写在指定的地方，否则就不给你加载)。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JVM/" rel="tag"># JVM</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/java/learn-java-003/" rel="prev" title="死磕Java并发-深入分析volatile的实现原理">
                  <i class="fa fa-chevron-left"></i> 死磕Java并发-深入分析volatile的实现原理
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/jvm/learn-jvm-002/" rel="next" title="JVM系列之jvm内存结构">
                  JVM系列之jvm内存结构 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NexT</span>
</div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <a href="https://theme-next.js.org/">NexT.Gemini</a> 强力驱动
  </div><div class="footer-custom">
Website source code <span class="exturl theme-link" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG8tbmV4dC9oZXhvLW5leHQuZ2l0aHViLmlv">here</span>
</div>


    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhcHB5NTE4" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.8/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/comments.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/motion.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/next-boot.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/pjax.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/third-party/search/local-search.min.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.4.0/mermaid.min.js","integrity":"sha256-3JloMMI/ZQx6ryuhhZTsQJQmGAkXeni6PkshX7UUO2s="}}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/third-party/tags/mermaid.min.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/third-party/math/mathjax.min.js"></script>



</body>
</html>
