<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="5AUIVYTbHIAuz-eQtxSfZbWW5eg9_EVZMSQycIuXrG0">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"theme-next.js.org","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.15.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/config.min.js"></script>

    <meta name="description" content="redis内置的命令行redis-cli，它背后强大的功能绝大数同学可能闻所未闻，一起挖掘这些鲜为人知的有趣用法">
<meta property="og:type" content="article">
<meta property="og:title" content="redis命令行工具有趣的罕见用法">
<meta property="og:url" content="https://theme-next.js.org/redis/2018-10-29-%E7%9F%AD%E5%B0%8F%E7%B2%BE%E6%82%8D%E4%B9%8B%20Redis%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E6%9C%89%E8%B6%A3%E7%9A%84%E7%BD%95%E8%A7%81%E7%94%A8%E6%B3%95/index.html">
<meta property="og:site_name" content="亦彤blog">
<meta property="og:description" content="redis内置的命令行redis-cli，它背后强大的功能绝大数同学可能闻所未闻，一起挖掘这些鲜为人知的有趣用法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14423059-f337861feec0a30e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="article:published_time" content="2018-10-28T16:00:00.000Z">
<meta property="article:modified_time" content="2022-03-10T05:49:23.492Z">
<meta property="article:author" content="yangpengbing">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/14423059-f337861feec0a30e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">


<link rel="canonical" href="https://theme-next.js.org/redis/2018-10-29-%E7%9F%AD%E5%B0%8F%E7%B2%BE%E6%82%8D%E4%B9%8B%20Redis%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E6%9C%89%E8%B6%A3%E7%9A%84%E7%BD%95%E8%A7%81%E7%94%A8%E6%B3%95/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://theme-next.js.org/redis/2018-10-29-%E7%9F%AD%E5%B0%8F%E7%B2%BE%E6%82%8D%E4%B9%8B%20Redis%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E6%9C%89%E8%B6%A3%E7%9A%84%E7%BD%95%E8%A7%81%E7%94%A8%E6%B3%95/","path":"redis/2018-10-29-短小精悍之 Redis 命令行工具有趣的罕见用法/","title":"redis命令行工具有趣的罕见用法"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>redis命令行工具有趣的罕见用法 | 亦彤blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-43861RVV8R"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-43861RVV8R","only_pageview":false}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/third-party/analytics/google-analytics.min.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="亦彤blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">亦彤blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-bell fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">58</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%8D%95%E6%9D%A1%E5%91%BD%E4%BB%A4"><span class="nav-number">1.</span> <span class="nav-text">执行单条命令</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%B9%E9%87%8F%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="nav-number">2.</span> <span class="nav-text">批量执行命令</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#set%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">3.</span> <span class="nav-text">set多行字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4"><span class="nav-number">4.</span> <span class="nav-text">重复执行指令</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%BC%E5%87%BAcsv"><span class="nav-number">5.</span> <span class="nav-text">导出csv</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%A7%E8%A1%8Clua%E8%84%9A%E6%9C%AC"><span class="nav-number">6.</span> <span class="nav-text">执行lua脚本</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8A%B6%E6%80%81"><span class="nav-number">7.</span> <span class="nav-text">监控服务器状态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%AB%E6%8F%8F%E5%A4%A7key-bigkeys"><span class="nav-number">8.</span> <span class="nav-text">扫描大key(bigkeys)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%87%E6%A0%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">9.</span> <span class="nav-text">采样服务器指令</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%8A%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%B6%E8%BF%9F"><span class="nav-number">10.</span> <span class="nav-text">诊断服务器延迟</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8Brdb%E5%A4%87%E4%BB%BD"><span class="nav-number">11.</span> <span class="nav-text">远程rdb备份</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E4%BB%8E%E5%BA%93"><span class="nav-number">12.</span> <span class="nav-text">模拟从库</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#keys"><span class="nav-number">13.</span> <span class="nav-text">keys</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#scan"><span class="nav-number">14.</span> <span class="nav-text">scan</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#slowlog"><span class="nav-number">15.</span> <span class="nav-text">slowlog</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#rename-command"><span class="nav-number">16.</span> <span class="nav-text">rename-command</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#monitor"><span class="nav-number">17.</span> <span class="nav-text">monitor</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#info"><span class="nav-number">18.</span> <span class="nav-text">info</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#config"><span class="nav-number">19.</span> <span class="nav-text">config</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#set"><span class="nav-number">20.</span> <span class="nav-text">set</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yangpengbing"
      src="/images/logo.svg">
  <p class="site-author-name" itemprop="name">yangpengbing</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhcHB5NTE4" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;happy518"><i class="fab fa-github fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>
<div class="cc-license animated" itemprop="sponsor">
  <span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="120" src="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://theme-next.js.org/redis/2018-10-29-%E7%9F%AD%E5%B0%8F%E7%B2%BE%E6%82%8D%E4%B9%8B%20Redis%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E6%9C%89%E8%B6%A3%E7%9A%84%E7%BD%95%E8%A7%81%E7%94%A8%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.svg">
      <meta itemprop="name" content="yangpengbing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亦彤blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="redis命令行工具有趣的罕见用法 | 亦彤blog">
      <meta itemprop="description" content="redis内置的命令行redis-cli，它背后强大的功能绝大数同学可能闻所未闻，一起挖掘这些鲜为人知的有趣用法">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          redis命令行工具有趣的罕见用法
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-29 00:00:00" itemprop="dateCreated datePublished" datetime="2018-10-29T00:00:00+08:00">2018-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">redis内置的命令行redis-cli，它背后强大的功能绝大数同学可能闻所未闻，一起挖掘这些鲜为人知的有趣用法</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>我们每天都在使用redis内置的redis-cli，久而久之以为它就是一个简单的交互式redis数据结构手工操作程序，但是它背后q强大的功能绝大多数同学可能闻所未闻，今天我们一起下来挖掘这些鲜为人知的有趣用法。</p>
<h1 id="执行单条命令"><a href="#执行单条命令" class="headerlink" title="执行单条命令"></a>执行单条命令</h1><p>平时在访问redis服务器，一般都会使用redis-cli进入交互模式，然后一问一答来读写服务器，这种情况下我们使用的是它的[交互模式]。还有另外一种[直接模式]，通过j将命令参数直接传递给redis-cli来执行指令并获取结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli incrby foo 5</span><br><span class="line">(integer) 5</span><br><span class="line"></span><br><span class="line">$ redis-cli incrby foo 5</span><br><span class="line">(integer) 10</span><br></pre></td></tr></table></figure>
<p>如果输出的内容比较大，还可以将输出c重定向到外部文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli info &gt; info.txt</span><br><span class="line"></span><br><span class="line">$ wc -l info.txt </span><br><span class="line">120 info.txt</span><br></pre></td></tr></table></figure>
<p>上面的命令指向的服务器是默认地址。如果想指定特定的服务器可以这样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// -n 2 表示使用地2个库，相当于 select 2</span><br><span class="line">$ redis-cli -h localhost -p 6379 -n 2 ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>

<h1 id="批量执行命令"><a href="#批量执行命令" class="headerlink" title="批量执行命令"></a>批量执行命令</h1><p>在平时线上开发过程中，有时候我们避免不了要手动造数据，然后倒入redis，通常我们会编写脚本来做这件事情，不过还有另外一直比较便捷的方式，那就是直接使用redis-clil来批量执行一系列指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat cmds.txt</span><br><span class="line">set foo1 bar1</span><br><span class="line">set foo2 bar2</span><br><span class="line">set foo3 bar3</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ cat cmds.txt | redis-cli</span><br></pre></td></tr></table></figure>
<p>上面的指令使用了Unix管道将catz指令的标准输出连接到redis-cli的标准输入，其实还可以直接使用输入重定向来批量之执行指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli &lt; cmds.txt</span><br></pre></td></tr></table></figure>

<h1 id="set多行字符串"><a href="#set多行字符串" class="headerlink" title="set多行字符串"></a>set多行字符串</h1><p>如果一个字符串有多行，你希望将它传入set指令，redis-cli要如何做？可以使用-x选项，该选项会使用标准输入后的内容作为最后一个参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat str.txt</span><br><span class="line">Ernest Hemingway once wrote,</span><br><span class="line">&quot;The world is a fine place and worth fighting for.&quot;</span><br><span class="line"></span><br><span class="line">I agree with the second part.</span><br><span class="line"></span><br><span class="line">$ redis-cli -x set foo &lt; str.txt</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">$ redis-cli get foo</span><br><span class="line">&quot;Ernest Hemingway once wrote,\n\&quot;The world is a fine place and worth fighting for.\&quot;\nI agree with the second part.\n&quot;</span><br></pre></td></tr></table></figure>

<h1 id="重复执行指令"><a href="#重复执行指令" class="headerlink" title="重复执行指令"></a>重复执行指令</h1><p>redis-cli还支持重复执行指令多次，每条执行执行之间设置一个时间间隔，如此便可以观察某条指令的输出内容时间变化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 间隔1s，执行5次，观察qps的变化</span><br><span class="line">$ redis-cli -r 5 -i 1 info | grep ops</span><br><span class="line">instantaneous_ops_per_sec:43469</span><br><span class="line">instantaneous_ops_per_sec:47460</span><br><span class="line">instantaneous_ops_per_sec:47699</span><br><span class="line">instantaneous_ops_per_sec:46434</span><br><span class="line">instantaneous_ops_per_sec:47216</span><br></pre></td></tr></table></figure>
<p>如果将次数设置为-1，那就是重复无数次永远的执行下去，如果不提供-i参数，那就是没有间隔，连续重复执行，在交互模式下也可以重复执行指令，形式上比较怪异，在指令前增加次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; 5 ping</span><br><span class="line">PONG</span><br><span class="line">PONG</span><br><span class="line">PONG</span><br><span class="line">PONG</span><br><span class="line">PONG</span><br><span class="line"></span><br><span class="line"># 下面的指令很可怕，你的屏幕要愤怒了</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; 10000 info</span><br><span class="line">.......</span><br></pre></td></tr></table></figure>

<h1 id="导出csv"><a href="#导出csv" class="headerlink" title="导出csv"></a>导出csv</h1><p>redis-cli不能一次导出整个库的内容为csv，但是可以导出单条指令输出结果为csv格式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli rpush lfoo a b c d e f g</span><br><span class="line">(integer) 7</span><br><span class="line"></span><br><span class="line">$ redis-cli --csv lrange lfoo 0 -1</span><br><span class="line">&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;</span><br><span class="line"></span><br><span class="line">$ redis-cli hmset hfoo a 1 b 2 c 3 d 4</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">$ redis-cli --csv hgetall hfoo</span><br><span class="line">&quot;a&quot;,&quot;1&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;,&quot;d&quot;,&quot;4&quot;</span><br></pre></td></tr></table></figure>
<p>当然这种导出功能比较弱，仅仅是一堆字符串用逗号隔开，不过你可以结合命令的批量执行看看多个指令的导出结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli --csv -r 5 hgetall hfoo</span><br><span class="line">&quot;a&quot;,&quot;1&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;,&quot;d&quot;,&quot;4&quot;</span><br><span class="line">&quot;a&quot;,&quot;1&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;,&quot;d&quot;,&quot;4&quot;</span><br><span class="line">&quot;a&quot;,&quot;1&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;,&quot;d&quot;,&quot;4&quot;</span><br><span class="line">&quot;a&quot;,&quot;1&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;,&quot;d&quot;,&quot;4&quot;</span><br><span class="line">&quot;a&quot;,&quot;1&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;,&quot;d&quot;,&quot;4&quot;</span><br></pre></td></tr></table></figure>
<p>看到这里应该明白--csv参数的效果就是对输出做了一次转换，用逗号隔开，经此而已。</p>
<h1 id="执行lua脚本"><a href="#执行lua脚本" class="headerlink" title="执行lua脚本"></a>执行lua脚本</h1><p>在lua脚本，我们可以使用eval指令之执行脚本字符串，每次都是将脚本内容压缩成单行字符串在调用eval指令，这非常繁琐，而且可读性很差，redis-cli考虑到这点，它可以直接执行脚本文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; eval &quot;return redis.pcall(&#x27;mset&#x27;, KEYS[1], ARGV[1], KEYS[2], ARGV[2])&quot; 2 foo1 foo2 bar1 bar2</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; eval &quot;return redis.pcall(&#x27;mget&#x27;, KEYS[1], KEYS[2])&quot; 2 foo1 foo2</span><br><span class="line">1) &quot;bar1&quot;</span><br><span class="line">2) &quot;bar2&quot;</span><br></pre></td></tr></table></figure>
<p>下面我们以脚本的形式来执行上面的指令，参数形式有所不同，KEY和ARGV之间需要使用逗号分割，并且不需要提供KEY的数量参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cat mset.txt</span><br><span class="line">return redis.pcall(&#x27;mset&#x27;, KEYS[1], ARGV[1], KEYS[2], ARGV[2])</span><br><span class="line"></span><br><span class="line">$ cat mget.txt</span><br><span class="line">return redis.pcall(&#x27;mget&#x27;, KEYS[1], KEYS[2])</span><br><span class="line"></span><br><span class="line">$ redis-cli --eval mset.txt foo1 foo2, bar1 bar2</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">$ redis-cli --eval mget.txt foo1 foo2</span><br><span class="line">1) &quot;bar1&quot;</span><br><span class="line">2) &quot;bar2&quot;</span><br></pre></td></tr></table></figure>
<p>如果你的lua脚本太长，--eval将大有用处。</p>
<h1 id="监控服务器状态"><a href="#监控服务器状态" class="headerlink" title="监控服务器状态"></a>监控服务器状态</h1><p>我们可以使用--stat参数来实时监控服务器的状态，间隔1s实时输出一次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli --stat</span><br><span class="line">------- data ------ --------------------- load -------------------- - child -</span><br><span class="line">keys mem clients blocked requests connections</span><br><span class="line">2 6.66M 100 0 11591628 (+0) 335</span><br><span class="line">2 6.66M 100 0 11653169 (+61541) 335</span><br><span class="line">2 6.66M 100 0 11706550 (+53381) 335</span><br><span class="line">2 6.54M 100 0 11758831 (+52281) 335</span><br><span class="line">2 6.66M 100 0 11803132 (+44301) 335</span><br><span class="line">2 6.66M 100 0 11854183 (+51051) 335</span><br></pre></td></tr></table></figure>
<p>如果你觉得间隔太短或者太长，可以使用-i参数调整输出间隔。</p>
<h1 id="扫描大key-bigkeys"><a href="#扫描大key-bigkeys" class="headerlink" title="扫描大key(bigkeys)"></a>扫描大key(bigkeys)</h1><p>这个功能太实用了，我已经在线上试过无数次了，每次遇到redis偶然卡顿问题，第一个想到的就是示例中是否存在大KEY，大key的内存扩容以及释放d都会导致主线程卡顿，如果想知道里面有没有大key，可以自己写程序扫描，不过这太繁琐了，redis-cli提供了--bigkeys参数可以很快扫出内存里面大key，使用-i参数控制扫描间隔，避免扫描指令导致服务器的ops徒增报警。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6380 --bigkeys</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line">-------- summary -------</span><br><span class="line"></span><br><span class="line">Sampled 526 keys in the keyspace!</span><br><span class="line">Total key length in bytes is 1524 (avg len 2.90)</span><br><span class="line"></span><br><span class="line">Biggest string found &#x27;test&#x27; has 10005 bytes</span><br><span class="line">Biggest   list found &#x27;commentlist&#x27; has 13 items</span><br><span class="line"></span><br><span class="line">524 strings with 15181 bytes (99.62% of keys, avg size 28.97)</span><br><span class="line">2 lists with 19 items (00.38% of keys, avg size 9.50)</span><br><span class="line">0 sets with 0 members (00.00% of keys, avg size 0.00)</span><br><span class="line">0 hashs with 0 fields (00.00% of keys, avg size 0.00)</span><br><span class="line">0 zsets with 0 members (00.00% of keys, avg size 0.00)</span><br></pre></td></tr></table></figure>
<p>最后5行可知, 没有set,hash,zset几种数据结构的数据, string类型有524个, list类型有两个, 通过bigkeys可知, 最大string结构的key是test, 最大list结构的key是commentList.</p>
<p>需要注意的是, 这个bigkeys得到的最大, 不一定是最大, 说明原因前, 首先说明bigkeys的原理, 非常简单, 通过scan命令遍历, 各种不同的数据结构的key, 分别通过不同的命令得到最大的key.</p>
<ul>
<li>如果是string结构, 通过strlen判断.</li>
<li>如果是list结构, 通过llen判断.</li>
<li>如果是hash结构, 通过hlen判断.</li>
<li>如果是set结构, 通过scard判断.</li>
<li>如果是zset结构, 通过zcard判断.</li>
</ul>
<p>正因为这种的判断方式, 虽然string结构肯定可以正确的删选出来最占用内存, 也就是最大的key, 但list不一定, 例如, 现在有两个list类型的key, 分别是numberlist--[0, 1, 2], stringlist--[&quot;123456789123456789&quot;], 由于通过llen判断, 所以numberlist要大于stringlist. 而事实上stringlist更占用内存, 其他三种数据结构hash, set, sorted set都会存在这个问题, 使用bigkeys一定要注意这一点.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli --bigkeys -i 0.01</span><br><span class="line"># Scanning the entire keyspace to find biggest keys as well as</span><br><span class="line"></span><br><span class="line"># average sizes per key type. You can use -i 0.1 to sleep 0.1 sec</span><br><span class="line"></span><br><span class="line"># per 100 SCAN commands (not usually needed).</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[00.00%] Biggest zset found so far &#x27;hist:aht:main:async_finish:20180425:17&#x27; with 1440 members</span><br><span class="line"></span><br><span class="line">[00.00%] Biggest zset found so far &#x27;hist:qps:async:authorize:20170311:27&#x27; with 2465 members</span><br><span class="line"></span><br><span class="line">[00.00%] Biggest hash found so far &#x27;job:counters:6ya9ypu6ckcl&#x27; with 3 fields</span><br><span class="line"></span><br><span class="line">[00.01%] Biggest string found so far &#x27;rt:aht:main:device_online:68:&#123;-4&#125;&#x27; with 4 bytes</span><br><span class="line"></span><br><span class="line">[00.01%] Biggest zset found so far &#x27;machine:load:20180709&#x27; with 2879 members</span><br><span class="line"></span><br><span class="line">[00.02%] Biggest string found so far &#x27;6y6fze8kj7cy:&#123;-7&#125;&#x27; with 90 bytes</span><br></pre></td></tr></table></figure>
<p>redis-cli对于每一种对象类型都会记录长度最大的key，对于每一种对象类型，刷新一次最高记录就会立即输出一次，它能保证输出长度为top1的key，但是top2和top3等key是无法保证可以扫描出来的，一般的处理方法是多扫描几次，或者是消灭了top1的key之后在扫描确认还有没有比较大的key。</p>
<h1 id="采样服务器指令"><a href="#采样服务器指令" class="headerlink" title="采样服务器指令"></a>采样服务器指令</h1><p>现在线上有一台redis服务器的ops太高了，有很多业务模块都在使用这个redis，如何才能判断出来是哪个业务导致ops异常的高，这时可以对线上的服务器的指令进行采样，观察采样的指令大致就可以分析出ops占用比较高的业务点，这时就要是有monitor指令，它会将服务器瞬间执行的指令全部显示出来，不过使用的时候需要注意的是使用Ctrl+C中断，否则你的显示器会噼里啪啦太多指令瞬间让你眼花缭乱。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli --host 192.168.x.x --port 6379 monitor</span><br><span class="line">1539853410.458483 [0 10.100.90.62:34365] &quot;GET&quot; &quot;6yax3eb6etq8:&#123;-7&#125;&quot;</span><br><span class="line">1539853410.459212 [0 10.100.90.61:56659] &quot;PFADD&quot; &quot;growth:dau:20181018&quot; &quot;2klxkimass8w&quot;</span><br><span class="line">1539853410.462938 [0 10.100.90.62:20681] &quot;GET&quot; &quot;6yax3eb6etq8:&#123;-7&#125;&quot;</span><br><span class="line">1539853410.467231 [0 10.100.90.61:40277] &quot;PFADD&quot; &quot;growth:dau:20181018&quot; &quot;2kei0to86ps1&quot;</span><br><span class="line">1539853410.470319 [0 10.100.90.62:34365] &quot;GET&quot; &quot;6yax3eb6etq8:&#123;-7&#125;&quot;</span><br><span class="line">1539853410.473927 [0 10.100.90.61:58128] &quot;GET&quot; &quot;6yax3eb6etq8:&#123;-7&#125;&quot;</span><br><span class="line">1539853410.475712 [0 10.100.90.61:40277] &quot;PFADD&quot; &quot;growth:dau:20181018&quot; &quot;2km8sqhlefpc&quot;</span><br><span class="line">1539853410.477053 [0 10.100.90.62:61292] &quot;GET&quot; &quot;6yax3eb6etq8:&#123;-7&#125;&quot;</span><br></pre></td></tr></table></figure>

<h1 id="诊断服务器延迟"><a href="#诊断服务器延迟" class="headerlink" title="诊断服务器延迟"></a>诊断服务器延迟</h1><p>平时我们诊断两台服务器的延迟一般是使用Unix的ping指令，redis也提供了延迟诊断的指令，不过它的原理不太一样，它是诊断d当前机器和redis服务器之间的指令(ping指令)时延, 它不仅仅是物理网络的时延，还和当前redis主线程是否忙碌有关，如果你发现Unix的ping指令时延很小，而redis的时延很大，说明redis服务器在执行指令时有微弱的卡顿。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli --host 192.168.x.x --port 6379 --latency</span><br><span class="line">min: 0, max: 5, avg: 0.08 (305 samples)</span><br></pre></td></tr></table></figure>
<p>时延的单位是ms，redis-cli还能显示时延的分布情况，而且是图形化输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli --latency-dist</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/14423059-f337861feec0a30e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" loading="lazy"></p>
<h1 id="远程rdb备份"><a href="#远程rdb备份" class="headerlink" title="远程rdb备份"></a>远程rdb备份</h1><p>执行下面的命令就可以将远程的redis实例备份到本地机器，远程服务器会执行一次bgsave操作，将远程的的rdb文件传输到客户端，远程rdb备份让我们有一种&quot;秀才不出门，全知天下事&quot;的感觉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli --host 192.168.x.x --port 6379 --rdb ,/usr.rdb</span><br><span class="line">SYNC sent to master, writing 2501265095 bytes to &#x27;./user.rdb&#x27;</span><br><span class="line"></span><br><span class="line">Transfer finished with success.</span><br></pre></td></tr></table></figure>

<h1 id="模拟从库"><a href="#模拟从库" class="headerlink" title="模拟从库"></a>模拟从库</h1><p>如果你想观察主从服务器之间都同步了那些数据，可以使用redis-cli模拟从库。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -h 192.168.x.x -p 6379 --slave</span><br><span class="line">SYNC with master, discarding 51778306 bytes of bulk transfer...</span><br><span class="line"></span><br><span class="line">SYNC done. Logging commands from master.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从库连上主库的第一件事情就是全量同步，所以看到上面的指令卡顿这很正常，待首次全量同步完成后，就会输出增量的aof日志。</p>
<h1 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h1><p>因为使用keys这个命令，导致出现性能毛刺，这个命令的时间复杂度是0(n), 而且redis又是单线程执行的，在执行keys时即使是时间复杂度只有o(1), set或者get这种简单命令也会堵塞，从而导致这个时间点性能抖动，甚至可能出现timeout。</p>
<blockquote>
<p>强烈建议生产环境屏蔽keys命令</p>
</blockquote>
<h1 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h1><p>既然keys命令不允许使用，那么有什么替代方案呢，有，那就是scan命令，如果把keys命令比作类似select * from users where username like &quot;%fei%&quot;这种SQL，那么scan应该是select * from users where id &gt; ? limit 10;这种命令。</p>
<p>官方文档用法如下：</p>
<blockquote>
<p>SCAN cursor [MATCH pattern] [COUNT count]</p>
</blockquote>
<p>初始化执行scan命令例如 scan0。SCAN命令是一个基于游标的迭代器，这意味着命令每次被调用都需要使用上一次这个调用返回的游标作为该次调用的游标参数，以此来延续之前的迭代过程，当SCAN命令的游标参数被设置为0时，服务器将开始一次新的迭代，而当redis服务器向用户返回值为0的游标时，表示迭代已结束，这是唯一迭代结束的判定方式，而不能通过返回结果集是否为空判断迭代结束。</p>
<p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 </span><br><span class="line">1) &quot;0&quot;                 </span><br><span class="line">2) 1) &quot;foo&quot;</span><br></pre></td></tr></table></figure>
<p>返回结果分为两部分: 第一部分即1) 就是下一次迭代游标，第二部分即2) 就是本次迭代结果集。</p>
<h1 id="slowlog"><a href="#slowlog" class="headerlink" title="slowlog"></a>slowlog</h1><p>上面提到不能使用keysm命令，如果就有开发这么做了呢，我们该如何得知，与其他任意存储系统例如mysql， mongodb可以查看慢日志一样，redis也可以，即通过slowlog命令，用法如下：</p>
<blockquote>
<p>SLOWLOG subcommand [argument]</p>
</blockquote>
<p>subcommand主要有：</p>
<ul>
<li>get: 用法：slowlog get [argument], 获取argument参数指定数量的慢日志。</li>
<li>len: 用法：slowlog len, 总慢日志数量。</li>
<li>reset: 用法: slowlog reset, 清空慢日志.</li>
</ul>
<p>执行结果如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>&gt; slowlog get <span class="number">5</span></span><br><span class="line"><span class="number">1</span>) <span class="number">1</span>) (integer) <span class="number">2</span></span><br><span class="line">   <span class="number">2</span>) (integer) <span class="number">1532656201</span></span><br><span class="line">   <span class="number">3</span>) (integer) <span class="number">2033</span></span><br><span class="line">   <span class="number">4</span>) <span class="number">1</span>) <span class="string">&quot;flushddbb&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="number">1</span>) (integer) <span class="number">1</span>  ----  慢日志编码，一般不用care</span><br><span class="line">   <span class="number">2</span>) (integer) <span class="number">1532646897</span>  ----  导致慢日志的命令执行的时间点，如果api有timeout，可以通过对比这个时间，判断可能是慢日志命令执行导致的</span><br><span class="line">   <span class="number">3</span>) (integer) <span class="number">26424</span>  ----  导致慢日志执行的redis命令，通过<span class="number">4</span>)可知，执行config rewrite导致慢日志，总耗时26ms+</span><br><span class="line">   <span class="number">4</span>) <span class="number">1</span>) <span class="string">&quot;config&quot;</span></span><br><span class="line">      <span class="number">2</span>) <span class="string">&quot;rewrite&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>命令耗时超过多少才会保存到slowlog中,可以通过命令config set slowlog-log-slower-than 2000 配置并且不需要重新启动redis, 注意: 单位是微秒, 2000微妙即2毫秒.</p>
</blockquote>
<h1 id="rename-command"><a href="#rename-command" class="headerlink" title="rename-command"></a>rename-command</h1><p>为了防止把问题带到生产环境, 我们可以通过配置文件重命名一些危险命令, 例如 keys等一些高危命令, 操作非常简单, 只需要在conf配置文件增加如下所示配置即可: </p>
<blockquote>
<p>rename-command flushdb flushddbb <br><br>rename-command flushall flushallall <br><br>rename-command keys keysys</p>
</blockquote>
<h1 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h1><p>假设生产环境没有屏蔽keys等一些高非命令, 并且slowlog中还不断有新的keys导致慢日志. 那我们如何揪出这些命令是由谁执行的呢? 这是就是monitor的用处, 用法如下:</p>
<blockquote>
<p>redis-cli -h 127.0.0.1 -p 6379 -n 0 monitor</p>
</blockquote>
<p>如果当前redis环境ops比较高, 那么建议结合linux管道命令优化, 只输出keys命令的执行情况:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[afei@redis ~]# redis-cli -p 6380 monitor | grep keys </span><br><span class="line">1532645266.656525 [0 10.0.0.1:43544] &quot;keyss&quot; &quot;*&quot;</span><br><span class="line">1532645287.257657 [0 10.0.0.1:43544] &quot;keyss&quot; &quot;44*&quot;</span><br></pre></td></tr></table></figure>
<p>执行结果中很清楚的看到keys命令执行来源, 通过输出ip地址和端口信息, 就能在目标服务器上找到执行这条命令的进程, 揪出元凶, 勒令整改.</p>
<h1 id="info"><a href="#info" class="headerlink" title="info"></a>info</h1><p>如果说哪个命令能最全面反映当前redis运行情况, 那非info莫属, 用法如下: </p>
<blockquote>
<p>INFO [section]</p>
</blockquote>
<p>section可选值有:</p>
<ul>
<li>Server: 运行的redis实例一些信息, 包括redis版本, 操作系统信息, 端口, GCC版本, 配置文件路径等.</li>
<li>Clients: redis客户端信息, 包括已连接客户端数量, 阻塞客户端数量等;</li>
<li>Memory: 使用内存, 峰值内存, 内存碎片率, 内存分配方式, 这几个参数都非常重要.</li>
<li>Persistence: AOF和RDB持久化信息.</li>
<li>Stats: 一些统计信息, 最重要的三个参数: OPS(instantaneous_ops_per_sec), keyspace_hits和keyspace_misses两个参数反应缓存命中率.</li>
<li>Replication: redis集群信息.</li>
<li>CPU: cpu相关信息.</li>
<li>keyspace: redis中各个DB里key的信息.</li>
</ul>
<h1 id="config"><a href="#config" class="headerlink" title="config"></a>config</h1><p>config是一个非常有价值的命令, 主要体现在对于redis的运维, 因为生产环境一般是不允许随意重启的, 不能因为需要调优一些参数就修改conf配置文件并重启, redis作者早就想到了这一点, 通过config命令能热修改一些配置, 不需要重启redis实例, 可以通过如下命令查看那些参数可以热修改:</p>
<blockquote>
<p>config get *</p>
</blockquote>
<p>热修改就比较容易了, 执行如下命令即可:</p>
<blockquote>
<p>config set </p>
</blockquote>
<p>例如: config set slowlog-max-len 100, config set maxclients 1024</p>
<p>这样修改的话, 如果以后由于某些原因redis实例故障需要重启, 那通过config热修改的参数就会被配置文件中的参数覆盖, 所以我们需要通过一个命令将config热修改的参数刷新到redis配置文件中持久化, 通过执行如下命令即可:</p>
<blockquote>
<p>config rewrite</p>
</blockquote>
<p>执行完该命令后, 我们能能在config文件中看到类似这种信息:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 如果conf中本来就有这个参数, 通过执行config set, 那么redis直接原地修改配置文件</span><br><span class="line">maxclients 1024</span><br><span class="line"></span><br><span class="line"># 如果conf中没有这个参数, 通过执行config set, 那么redis会追加在Generated by CONFIG REWRITE字样后面</span><br><span class="line"># Generated by CONFIG REWRITE</span><br><span class="line">save 600 60</span><br><span class="line">slowlog-max-len 100</span><br></pre></td></tr></table></figure>
<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>官方文档介绍的用法如下:</p>
<blockquote>
<p>SET key value [Ex seconds] [PX milliseconds [NX|XX]</p>
</blockquote>
<p>你可能用的比较多的就是set key value, 或者 SRTEX key seconds value, 所以很多同学用redis实现分布式锁分为两步, 首先执行SETNX key value, 然后执行EXPIRE key seconds. 很明显,这种实现有很严重的问题, 因为分两步执行不具备原子性, 如果执行第一个命令后出现某些未知异常导致无法执行EXPIRE key seconds, 那么分布式锁就会一直无法释放.</p>
<p>通过SET命令实现分布式锁的正确姿势应该是SET key vlaue EX seconds NX (EX和PX任选, 取决于过期时间精度要求), 另外, value也有要求, 最好是一个类型UUID这种具备唯一性的字符串, 当然如果问你redis是否还有其他实现分布式锁的方案, 你能说出redlock.</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/redis/" rel="tag"># redis</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/redis/%E4%B8%BA%E4%BB%80%E4%B9%88redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F/" rel="prev" title="为什么redis是单线程的">
                  <i class="fa fa-chevron-left"></i> 为什么redis是单线程的
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018-10-30-%E5%B8%B8%E7%94%A8%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E6%8C%87%E5%8D%97/" rel="next" title="常用性能监控指南">
                  常用性能监控指南 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NexT</span>
</div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <a href="https://theme-next.js.org/">NexT.Gemini</a> 强力驱动
  </div><div class="footer-custom">
Website source code <span class="exturl theme-link" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG8tbmV4dC9oZXhvLW5leHQuZ2l0aHViLmlv">here</span>
</div>


    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhcHB5NTE4" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.8/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/comments.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/motion.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/next-boot.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/pjax.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/third-party/search/local-search.min.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.4.0/mermaid.min.js","integrity":"sha256-3JloMMI/ZQx6ryuhhZTsQJQmGAkXeni6PkshX7UUO2s="}}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/third-party/tags/mermaid.min.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.15.0/third-party/math/mathjax.min.js"></script>



</body>
</html>
